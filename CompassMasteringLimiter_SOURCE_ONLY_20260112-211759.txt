SOURCE CODE DUMP ONLY
ROOT: /Volumes/CMB_SSD/CompassMemory/2_Projects/CompassMasteringLimiter/3_Code/CompassMasteringLimiter
GENERATED: 20260112-211759
FILES: 4
================================================================================

================================================================================
FILE: Source/Plugin/PluginEditor.cpp
================================================================================
#include "PluginEditor.h"

static void setRotary (juce::Slider& s)
{
    s.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    s.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 88, 20);

    // Force visibility on dark UI (neutral, high-contrast; no "good/bad" color semantics)
    s.setColour (juce::Slider::rotarySliderOutlineColourId, juce::Colours::white.withAlpha (0.35f));
    s.setColour (juce::Slider::rotarySliderFillColourId,    juce::Colours::white.withAlpha (0.85f));
    s.setColour (juce::Slider::thumbColourId,               juce::Colours::white.withAlpha (0.90f));

    s.setColour (juce::Slider::textBoxTextColourId,         juce::Colours::white.withAlpha (0.90f));
    s.setColour (juce::Slider::textBoxOutlineColourId,      juce::Colours::white.withAlpha (0.25f));
    s.setColour (juce::Slider::textBoxBackgroundColourId,   juce::Colours::transparentBlack);
}

CompassMasteringLimiterAudioProcessorEditor::CompassMasteringLimiterAudioProcessorEditor (CompassMasteringLimiterAudioProcessor& p)
: juce::AudioProcessorEditor (&p), processor (p)
{
    setResizable (false, false);
    setSize (820, 260);

    setRotary (drive);
    addAndMakeVisible (drive);

    setRotary (ceiling);
    addAndMakeVisible (ceiling);
    adaptiveBias.addItem ("Transparent", 1);
    adaptiveBias.addItem ("Balanced", 2);
    adaptiveBias.addItem ("Aggressive", 3);
    addAndMakeVisible (adaptiveBias);

    stereoLink.setSliderStyle (juce::Slider::LinearHorizontal);
    stereoLink.setTextBoxStyle (juce::Slider::TextBoxRight, false, 90, 20);
    addAndMakeVisible (stereoLink);

    oversamplingMin.addItem ("2x", 1);
    oversamplingMin.addItem ("4x", 2);
    oversamplingMin.addItem ("8x", 3);
    addAndMakeVisible (oversamplingMin);

    addAndMakeVisible (grMeter);
    grMeter.setInterceptsMouseClicks (false, false);
    grMeter.toBack();

    currentGrLabel.setJustificationType (juce::Justification::centredRight);
    currentGrLabel.setFont (juce::Font (14.0f));
    currentGrLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    currentGrLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    currentGrLabel.setInterceptsMouseClicks (false, false);
    currentGrLabel.setText ("0.0 dB", juce::dontSendNotification);
    addAndMakeVisible (currentGrLabel);

    auto& vts = processor.getAPVTS();

    driveA   = std::make_unique<APVTS::SliderAttachment> (vts, "drive", drive);
    ceilingA = std::make_unique<APVTS::SliderAttachment> (vts, "ceiling", ceiling);
    biasA    = std::make_unique<APVTS::ComboBoxAttachment> (vts, "adaptive_bias", adaptiveBias);
    linkA    = std::make_unique<APVTS::SliderAttachment> (vts, "stereo_link", stereoLink);
    osA      = std::make_unique<APVTS::ComboBoxAttachment> (vts, "oversampling_min", oversamplingMin);

    startTimerHz (30);
}

void CompassMasteringLimiterAudioProcessorEditor::timerCallback()
{
    const float current = processor.getCurrentGRDb();

    grMeter.pushValueDb (current);
    currentGrLabel.setText (juce::String::formatted ("%.1f dB", current), juce::dontSendNotification);

    grMeter.repaint();
}

void CompassMasteringLimiterAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);

    // Title
    g.setColour (juce::Colours::white.withAlpha (0.85f));
    g.setFont (14.0f);
    g.drawText ("Compass Mastering Limiter", 16, 10, getWidth() - 32, 20, juce::Justification::left);

    // Static labels (constitution: labeling for all visible controls)
    auto drawLabelAbove = [&] (const juce::Component& c, const juce::String& label)
    {
        auto r = c.getBounds().translated (0, -18);
        r.setHeight (16);
        g.setColour (juce::Colours::white.withAlpha (0.70f));
        g.setFont (12.5f);
        g.drawText (label, r, juce::Justification::centred, false);
    };

    drawLabelAbove (drive,           "Drive");
    drawLabelAbove (ceiling,         "Ceiling");
    drawLabelAbove (adaptiveBias,    "Adaptive Bias");
    drawLabelAbove (stereoLink,      "Stereo Link");
    drawLabelAbove (oversamplingMin, "Oversampling Min");
}

void CompassMasteringLimiterAudioProcessorEditor::resized()
{
    auto b = getLocalBounds().reduced (16);
    b.removeFromTop (30);

    const int knob = 104;
    const int gap  = 16;

    auto row = b.removeFromTop (knob + 30);

    drive.setBounds (row.removeFromLeft (knob));
    row.removeFromLeft (gap);
    ceiling.setBounds (row.removeFromLeft (knob));
    row.removeFromLeft (gap);

    adaptiveBias.setBounds (row.removeFromLeft (260).withTrimmedTop (34).withHeight (26));
    row.removeFromLeft (gap);
    stereoLink.setBounds (row.removeFromLeft (260).withTrimmedTop (34).withHeight (26));
    row.removeFromLeft (gap);
    oversamplingMin.setBounds (row.removeFromLeft (100).withTrimmedTop (34).withHeight (26));

    b.removeFromTop (10);
    grMeter.setBounds (b.removeFromTop (110));

    auto m = grMeter.getBounds();
    currentGrLabel.setBounds (m.getRight() - 90, m.getY() + 6, 84, 18);
}

================================================================================
FILE: Source/Plugin/PluginEditor.h
================================================================================
#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <cmath>
#include "PluginProcessor.h"

class GRHistoryMeter final : public juce::Component
{
public:
    void pushValueDb (float grDb) noexcept
    {
        if (! std::isfinite (grDb)) grDb = 0.0f;
        grDb = juce::jlimit (-60.0f, 0.0f, grDb);

        history[(size_t) head] = grDb;
        head = (head + 1) % kMax;
        if (head == 0) filled = true;
    }

    void paint (juce::Graphics& g) override
    {
        auto r = getLocalBounds().toFloat().reduced (6.0f);

        // Restrained background (observational, no drama)
        g.setColour (juce::Colours::white.withAlpha (0.10f));
        g.fillRoundedRectangle (r, 8.0f);

        auto yForDb = [&] (float db) -> float
        {
            const float n = (juce::jlimit (-60.0f, 0.0f, db) + 60.0f) / 60.0f; // 0..1
            return r.getBottom() - r.getHeight() * n; // 0 dB at top, -60 dB at bottom
        };

        const int count = filled ? kMax : head;
        if (count > 2)
        {
            juce::Path p;
            const float dx = r.getWidth() / (float) (count - 1);

            auto sampleAt = [&] (int i) -> float
            {
                const int idx = filled ? (head + i) % kMax : i;
                return history[(size_t) idx];
            };

            p.startNewSubPath (r.getX(), yForDb (sampleAt (0)));
            for (int i = 1; i < count; ++i)
                p.lineTo (r.getX() + dx * (float) i, yForDb (sampleAt (i)));

            // History path only (primary + only visual)
            g.setColour (juce::Colours::white.withAlpha (0.60f));
            g.strokePath (p, juce::PathStrokeType (1.5f));
        }
    }

private:
    static constexpr int kMax = 120;
    std::array<float, (size_t) kMax> history {};
    int head = 0;
    bool filled = false;
};

class CompassMasteringLimiterAudioProcessorEditor final
    : public juce::AudioProcessorEditor
    , private juce::Timer
{
public:
    explicit CompassMasteringLimiterAudioProcessorEditor (CompassMasteringLimiterAudioProcessor&);
    ~CompassMasteringLimiterAudioProcessorEditor() override = default;

    void paint (juce::Graphics&) override;
    void resized() override;

private:
    void timerCallback() override;

    CompassMasteringLimiterAudioProcessor& processor;

    juce::Slider drive;
    juce::Slider ceiling;
    juce::ComboBox adaptiveBias;
    juce::Slider stereoLink;
    juce::ComboBox oversamplingMin;

    GRHistoryMeter grMeter;
    juce::Label currentGrLabel;

    using APVTS = juce::AudioProcessorValueTreeState;
    std::unique_ptr<APVTS::SliderAttachment> driveA;
    std::unique_ptr<APVTS::SliderAttachment> ceilingA;
    std::unique_ptr<APVTS::ComboBoxAttachment> biasA;
    std::unique_ptr<APVTS::SliderAttachment> linkA;
    std::unique_ptr<APVTS::ComboBoxAttachment> osA;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CompassMasteringLimiterAudioProcessorEditor)
};

================================================================================
FILE: Source/Plugin/PluginProcessor.cpp
================================================================================
#include "PluginProcessor.h"
#include "PluginEditor.h"

CompassMasteringLimiterAudioProcessor::CompassMasteringLimiterAudioProcessor()
: juce::AudioProcessor (BusesProperties()
#if ! JucePlugin_IsMidiEffect
 #if ! JucePlugin_IsSynth
    .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
 #endif
    .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
#endif
)
{
    apvts = std::make_unique<APVTS>(*this, nullptr, "PARAMS", createParameterLayout());
}

CompassMasteringLimiterAudioProcessor::APVTS::ParameterLayout
CompassMasteringLimiterAudioProcessor::createParameterLayout()
{
    APVTS::ParameterLayout layout;

    // IDs are constitution-locked (no aliases, no hidden controls)
    // Value ranges are defined exactly per Gate-2 spec.
    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "drive", 1 },
        "Drive",
        juce::NormalisableRange<float> { 0.0f, 20.0f, 0.01f },
        0.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dB"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "ceiling", 1 },
        "Ceiling",
        juce::NormalisableRange<float> { -6.0f, 0.0f, 0.01f },
        -0.3f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dBTP"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "adaptive_bias", 1 },
        "Adaptive Bias",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.5f },
        0.5f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int)
        {
            // Constitution: continuous scalar with discrete UI labels mapped to fixed scalar points.
            // Enforced scalar points: 0.0=Transparent, 0.5=Balanced, 1.0=Aggressive
            if (v <= 0.25f) return juce::String ("Transparent");
            if (v >= 0.75f) return juce::String ("Aggressive");
            return juce::String ("Balanced");
        },
        [] (const juce::String& s)
        {
            if (s.equalsIgnoreCase ("Transparent")) return 0.0f;
            if (s.equalsIgnoreCase ("Balanced"))    return 0.5f;
            if (s.equalsIgnoreCase ("Aggressive"))  return 1.0f;

            const float v = s.getFloatValue();
            const float vc = juce::jlimit (0.0f, 1.0f, v);
            const float snapped = std::round (vc * 2.0f) * 0.5f; // -> {0.0, 0.5, 1.0}
            return juce::jlimit (0.0f, 1.0f, snapped);
        }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "stereo_link", 1 },
        "Stereo Link",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v * 100.0f, 1) + " %"; },
        [] (const juce::String& s) { return s.getFloatValue() / 100.0f; }
    ));

    layout.add (std::make_unique<juce::AudioParameterChoice>(
        juce::ParameterID { "oversampling_min", 1 },
        "Oversampling Min",
        juce::StringArray { "2x", "4x", "8x" },
        0
    ));

    return layout;
}

void CompassMasteringLimiterAudioProcessor::reset (double sampleRate, int maxBlock, int channels) noexcept
{
    lastSampleRate = (sampleRate > 0.0 ? sampleRate : 44100.0);
    lastInvSampleRate = 1.0 / juce::jmax (1.0, lastSampleRate);
    effectiveControlInvDt = lastInvSampleRate;
    effectiveAudioInvDt   = lastInvSampleRate; // OSFactor=1.0 until oversampled audio-path processing is introduced
    lastMaxBlock   = (maxBlock > 0 ? maxBlock : 0);
    lastChannels   = (channels > 0 ? channels : 0);

    // Deterministic reset of adaptive/envelope/guard state:
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.reset (lastSampleRate, 0.020);        // 20 ms
    ceilingDbSmoothed.reset (lastSampleRate, 0.020);      // 20 ms
    adaptiveBias01Smoothed.reset (lastSampleRate, 0.050); // 50 ms
    stereoLink01Smoothed.reset (lastSampleRate, 0.050);   // 50 ms

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);

    // Envelope state reset (deterministic; bounded)
    microStage1DbState = { 0.0, 0.0 };
    microStage2DbState = { 0.0, 0.0 };
    macroEnergyState   = { 0.0, 0.0 };

    lastAttnTargetDb   = { 0.0, 0.0 };
    lastAppliedAttnDb  = { 0.0, 0.0 };

    // Spectral Guardrails state (measurement-only)
    guardLpState = { 0.0, 0.0 };
    guardTotE    = { 0.0, 0.0 };
    guardHiE     = { 0.0, 0.0 };
    crestRmsSqState    = { 0.0, 0.0 };
    eventDensityState  = { 0.0, 0.0 };

    lastOutScalar = { 1.0f, 1.0f };
}

void CompassMasteringLimiterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
    reset (sampleRate, samplesPerBlock, ch);

    // Prebuild oversampling instances (no allocations in audio thread).
    prepareOversampling (ch, samplesPerBlock);

    // Latch initial oversampling selection (treated as transport-safe init).
    const int osMinIndex = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    selectOversamplingAtBoundary (osMinIndex);

    // Transport becomes unknown on prepare (hosts differ); edge detection begins on first block.
    transportKnown = false;
    lastTransportPlaying = false;
}

void CompassMasteringLimiterAudioProcessor::releaseResources()
{
}

bool CompassMasteringLimiterAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (! out.isDisabled());
}


double CompassMasteringLimiterAudioProcessor::onePoleAlpha (double tauSec, double dtSec) noexcept
{
    return std::exp (-dtSec / juce::jmax (1.0e-9, tauSec));
}

void CompassMasteringLimiterAudioProcessor::processOneSample (float* const* chPtr,
                                                             int numCh,
                                                             int i,
                                                             double dt,
                                                             double driveDb,
                                                             double ceilingDb,
                                                             double bias01,
                                                             double link01,
                                                             double& grDbNegMin) noexcept
{
    // Softplus controls (smooth, monotonic, branch-free)
    constexpr double kEpsLin    = 1.0e-12; // avoids log(0)
    constexpr double kSoftK     = 32.0;
    constexpr double kMaxAttnDb = 120.0;

    // Time constants (seconds). Names avoid forbidden terminology.
    constexpr double kMacroSecBase = 0.1200; // 120 ms nominal

    std::array<double, 2> attnDbCh { 0.0, 0.0 };

    // Spectral Guardrails: parallel measurement (no influence on envelope)
    constexpr double kGuardFcHz   = 4500.0;
    constexpr double kGuardTauSec = 0.040;
    const double gGuardLp = std::exp (-2.0 * juce::MathConstants<double>::pi * kGuardFcHz * dt);
    const double aGuardE  = onePoleAlpha (kGuardTauSec, dt);

    const int chProc = juce::jmin (2, numCh);
    double guardrailHf01 = 0.0;

    for (int c = 0; c < chProc; ++c)
    {
        const double s = (double) chPtr[c][i];

        const double lp = gGuardLp * guardLpState[(size_t) c] + (1.0 - gGuardLp) * s;
        guardLpState[(size_t) c] = lp;
        const double hp = s - lp;

        const double s2  = s  * s;
        const double hp2 = hp * hp;

        guardTotE[(size_t) c] = aGuardE * guardTotE[(size_t) c] + (1.0 - aGuardE) * s2;
        guardHiE[(size_t) c]  = aGuardE * guardHiE[(size_t) c]  + (1.0 - aGuardE) * hp2;

        const double denom = guardTotE[(size_t) c] + 1.0e-18;
        const double hf = juce::jlimit (0.0, 1.0, guardHiE[(size_t) c] / denom);
        if (hf > guardrailHf01) guardrailHf01 = hf;

        const double tpDb = 20.0 * std::log10 (std::abs (s) + kEpsLin);

        const double x = (tpDb + driveDb) - ceilingDb;

        const double z = kSoftK * x;
        const double softplus = z + std::log1p (std::exp (-std::abs (z)));
        double attnTargetDb = softplus / kSoftK;
        attnTargetDb = juce::jlimit (0.0, kMaxAttnDb, attnTargetDb);

        constexpr double kGrFloorDb    = 0.05;
        constexpr double kHysteresisDb = 0.08;

        double currentTarget = attnTargetDb;
        if (currentTarget < kGrFloorDb)
            currentTarget = 0.0;
        else if (currentTarget < lastAttnTargetDb[(size_t) c] + kHysteresisDb)
            currentTarget = lastAttnTargetDb[(size_t) c];

        lastAttnTargetDb[(size_t) c] = currentTarget;
        attnTargetDb = currentTarget;

        const double energyInput = juce::jmax (0.0, std::pow (10.0, attnTargetDb / 20.0) - 1.0);

        const double macroSec = kMacroSecBase * (1.20 - 0.40 * bias01);
        const double aM = onePoleAlpha (macroSec, dt);
        macroEnergyState[(size_t) c] = aM * macroEnergyState[(size_t) c] + (1.0 - aM) * energyInput;

        const double macro01 = macroEnergyState[(size_t) c] / (1.0 + macroEnergyState[(size_t) c]);
        const double sustained01 = juce::jlimit (0.0, 1.0, macro01);

        constexpr double kCrestRmsSecBase = 0.050;
        const double crestRmsSec = kCrestRmsSecBase * (1.15 - 0.30 * bias01);
        const double aCR = onePoleAlpha (crestRmsSec, dt);
        const double absS = std::abs (s);
        crestRmsSqState[(size_t) c] = aCR * crestRmsSqState[(size_t) c] + (1.0 - aCR) * (absS * absS);
        const double rmsLin = std::sqrt (juce::jmax (0.0, crestRmsSqState[(size_t) c]));
        const double crest = absS / (rmsLin + 1.0e-12);
        const double crest01 = juce::jlimit (0.0, 1.0, (crest - 1.0) / (crest + 1.0));

        constexpr double kDensitySecBase = 0.090;
        const double densitySec = kDensitySecBase * (1.20 - 0.40 * bias01);
        const double aD = onePoleAlpha (densitySec, dt);
        const double densityInput = 1.0 - std::exp (-0.18 * attnTargetDb);
        eventDensityState[(size_t) c] = aD * eventDensityState[(size_t) c] + (1.0 - aD) * densityInput;
        const double density01 = juce::jlimit (0.0, 1.0, eventDensityState[(size_t) c]);

        constexpr double kMicroSecMin = 0.0030;
        constexpr double kMicroSecMax = 0.0600;

        const double hold01 = juce::jlimit (0.0, 1.0,
            (0.60 + 0.20 * (1.0 - bias01)) * sustained01 +
            (0.40 - 0.20 * (1.0 - bias01)) * density01);

        const double snap01 = crest01;

        const double resp01 = juce::jlimit (0.0, 1.0,
            (0.45 + 0.35 * bias01) * snap01 +
            (0.55 - 0.35 * bias01) * (1.0 - hold01));

        const double microSec = kMicroSecMin + (kMicroSecMax - kMicroSecMin) * (1.0 - resp01);

        const double aU = onePoleAlpha (microSec, dt);

        microStage1DbState[(size_t) c] = aU * microStage1DbState[(size_t) c] + (1.0 - aU) * attnTargetDb;
        microStage2DbState[(size_t) c] = aU * microStage2DbState[(size_t) c] + (1.0 - aU) * microStage1DbState[(size_t) c];

        double y1 = microStage2DbState[(size_t) c];
        y1 = juce::jlimit (0.0, kMaxAttnDb, y1);
        microStage2DbState[(size_t) c] = y1;

        attnDbCh[(size_t) c] = y1;
    }

    if (numCh > 2)
    {
        for (int c = 2; c < numCh; ++c)
            attnDbCh[1] = juce::jmax (attnDbCh[1], attnDbCh[0]);
    }

    const double linkedDb = juce::jmax (attnDbCh[0], attnDbCh[1]);
    const double outDbL0 = (1.0 - link01) * attnDbCh[0] + link01 * linkedDb;
    const double outDbR0 = (1.0 - link01) * attnDbCh[1] + link01 * linkedDb;

    double outDbL = outDbL0;
    double outDbR = outDbR0;
    {
        const bool overloadAssistOn = (overloadAssistBlocks > 0);
        const double grAbsDb = juce::jmax (outDbL, outDbR);

        constexpr double kGuardOnDb       = 3.0;
        constexpr double kGuardFullDb     = 12.0;
        constexpr double kGuardMaxExtraDb = 1.2;

        double t = 0.0;
        if (grAbsDb > kGuardOnDb)
            t = juce::jlimit (0.0, 1.0, (grAbsDb - kGuardOnDb) / (kGuardFullDb - kGuardOnDb));

        const double tSmooth = t * t * (3.0 - 2.0 * t);

        const double hf01 = juce::jlimit (0.0, 1.0, guardrailHf01);
        const double guardDb = overloadAssistOn ? 0.0
            : juce::jlimit (0.0, kGuardMaxExtraDb, tSmooth * hf01 * kGuardMaxExtraDb);

        outDbL += guardDb;
        outDbR += guardDb;
    }

    outDbL = juce::jlimit (0.0, kMaxAttnDb, outDbL);
    outDbR = juce::jlimit (0.0, kMaxAttnDb, outDbR);

    constexpr double kTinyGrDb = 0.03;
    if (outDbL < kTinyGrDb) outDbL = 0.0;
    if (outDbR < kTinyGrDb) outDbR = 0.0;

    constexpr double kMaxSlewDbPerSec = 600.0;
    const double maxDeltaDb = kMaxSlewDbPerSec * dt;

    const double prevL = lastAppliedAttnDb[0];
    const double prevR = lastAppliedAttnDb[1];

    outDbL = juce::jlimit (prevL - maxDeltaDb, prevL + maxDeltaDb, outDbL);
    outDbR = juce::jlimit (prevR - maxDeltaDb, prevR + maxDeltaDb, outDbR);

    lastAppliedAttnDb[0] = outDbL;
    lastAppliedAttnDb[1] = outDbR;

    if (! std::isfinite (outDbL) || ! std::isfinite (outDbR))
        badMathThisBlock = true;

    const double grDbNeg = -juce::jmax (outDbL, outDbR);
    if (grDbNeg < grDbNegMin)
        grDbNegMin = grDbNeg;

    const float gL0 = (float) std::pow (10.0, -outDbL / 20.0);
    const float gR0 = (float) std::pow (10.0, -outDbR / 20.0);

    constexpr double kOutTauSec = 0.005;
    const float aOut = (float) onePoleAlpha (kOutTauSec, dt);
    const float gL = lastOutScalar[0] * aOut + gL0 * (1.0f - aOut);
    const float gR = lastOutScalar[1] * aOut + gR0 * (1.0f - aOut);
    lastOutScalar[0] = gL;
    lastOutScalar[1] = gR;

    if (numCh >= 1) chPtr[0][i] *= gL;
    if (numCh >= 2) chPtr[1][i] *= gR;
    for (int c = 2; c < numCh; ++c) chPtr[c][i] *= gR;
}


void CompassMasteringLimiterAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals denormGuard;

    // FTZ/DAZ always on (JUCE-supported): prevents denormal CPU spikes on silence/tails.
    juce::FloatVectorOperations::disableDenormalisedNumberSupport (true);

    // NaN/Inf containment helpers
    auto isBadF = [] (float x) noexcept { return ! std::isfinite (x); };
    auto isBadD = [] (double x) noexcept { return ! std::isfinite (x); };

    badMathThisBlock = false;

   #if JUCE_DEBUG
    // Debug asserts for internal state invariants
    jassert (std::isfinite (truePeakLin));
    jassert (std::isfinite (microStage1DbState[0]) && std::isfinite (microStage1DbState[1]));
    jassert (std::isfinite (microStage2DbState[0]) && std::isfinite (microStage2DbState[1]));
    jassert (std::isfinite (macroEnergyState[0])   && std::isfinite (macroEnergyState[1]));
   #endif

    // Release containment: sanitize any bad carried state immediately (prevents propagation)
    if (isBadD (truePeakLin) ||
        isBadD (microStage1DbState[0]) || isBadD (microStage1DbState[1]) ||
        isBadD (microStage2DbState[0]) || isBadD (microStage2DbState[1]) ||
        isBadD (macroEnergyState[0])   || isBadD (macroEnergyState[1]))
    {
        truePeakLin = 0.0;
        microStage1DbState = { 0.0, 0.0 };
        microStage2DbState = { 0.0, 0.0 };
        macroEnergyState   = { 0.0, 0.0 };
        crestRmsSqState    = { 0.0, 0.0 };
        eventDensityState  = { 0.0, 0.0 };
        guardLpState       = { 0.0, 0.0 };
        guardTotE          = { 0.0, 0.0 };
        guardHiE           = { 0.0, 0.0 };
        lastAppliedAttnDb  = { 0.0, 0.0 };
    }

    // Gate-3 deterministic transport semantics:
    // transport stop/start resets adaptive/envelope/guard states and is the only safe boundary for oversampling selection.
    if (auto* ph = getPlayHead())
    {
        juce::AudioPlayHead::CurrentPositionInfo pos;
        if (ph->getCurrentPosition (pos))
        {
            const bool playingNow = pos.isPlaying;
            if (! transportKnown)
            {
                transportKnown = true;
                lastTransportPlaying = playingNow;
            }
            else if (playingNow != lastTransportPlaying)
            {
                lastTransportPlaying = playingNow;

                const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
                reset (lastSampleRate, lastMaxBlock, ch);

                // Transport-safe boundary: latch oversampling selection (no allocations here).
                const int osMinIndexBoundary = (int) apvts->getRawParameterValue ("oversampling_min")->load();
                selectOversamplingAtBoundary (osMinIndexBoundary);
            }
        }
    }

    // Gate-2 rule: read params once per block into locals (atomics -> locals).
    const float driveDbTarget   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDbTarget = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01Target    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01Target    = apvts->getRawParameterValue ("stereo_link")->load();
    const int   osMinIndex      = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    juce::ignoreUnused (osMinIndex);

    driveDbSmoothed.setTargetValue (driveDbTarget);
    ceilingDbSmoothed.setTargetValue (ceilingDbTarget);
    adaptiveBias01Smoothed.setTargetValue (bias01Target);
    stereoLink01Smoothed.setTargetValue (link01Target);

    const auto tBlockStart = juce::Time::getHighResolutionTicks();

    // Control-domain true peak measurement disabled in Phase0 (buffer-size CPU stress).
    // measureTruePeak (buffer);

    // Envelope System (Micro + Macro, coupled)
    // - All control-domain attenuation is computed in dB domain.
    // - Micro: critically damped 2nd-order follower of the instantaneous attenuation target (no overshoot).
    // - Macro: bounded energy accumulator influences micro recovery behavior (no competing control paths).
    // - Stereo linking occurs after per-channel envelope generation.
    {
        const int numCh = juce::jmin (getTotalNumInputChannels(), buffer.getNumChannels());
        const int n     = buffer.getNumSamples();
        if (numCh <= 0 || n <= 0)
            return;

        // Softplus controls (smooth, monotonic, branch-free)
        constexpr double kEpsLin    = 1.0e-12; // avoids log(0)
        constexpr double kSoftK     = 32.0;
        constexpr double kMaxAttnDb = 120.0;

        


        // Time constants (seconds). Names avoid forbidden terminology.
        // "Micro" is ultra-fast; "Macro" is slower density behavior.
        constexpr double kMicroSecBase = 0.0080; // 8 ms nominal
        constexpr double kMacroSecBase = 0.1200; // 120 ms nominal

        // Coupling strength: macro energy influences micro recovery speed.
        constexpr double kCouple = 1.25;

        // Oversampled audio-path processing (no allocations in audio thread).
        // Fallback to native-rate if scratch buffer is not prepared for this block size / channel count.
        const bool canOsAudio =
            (activeOversampler != nullptr) &&
            (workBufferFloat.getNumChannels() >= numCh) &&
            (workBufferFloat.getNumSamples()  >= n);

        if (canOsAudio)
        {
            // CPU fast-path: if this block cannot exceed Ceiling after Drive AND envelope state is at rest,
            // skip oversampling + heavy inner loop, but advance smoothers deterministically.
            bool skipOsFastPath = false;
            {
                // Only skip if envelope state is already effectively at rest (avoids dropping residual GR).
                constexpr double kRestDb = 1.0e-3;  // ~0.001 dB
                constexpr double kRestEn = 1.0e-6;  // tiny macro energy

                const bool envAtRest =
                    (std::abs (microStage2DbState[0]) <= kRestDb) &&
                    (std::abs (microStage2DbState[1]) <= kRestDb) &&
                    (std::abs (macroEnergyState[0])   <= kRestEn) &&
                    (std::abs (macroEnergyState[1])   <= kRestEn);

                if (envAtRest)
                {
                    float peak = 0.0f;
                    for (int c = 0; c < numCh; ++c)
                    {
                        const float* p = buffer.getReadPointer (c);
                        for (int i = 0; i < n; ++i)
                        {
                            const float a = std::abs (p[i]);
                            if (a > peak) peak = a;
                        }
                    }

                    // Conservative overshoot test using target values (no per-sample smoothing work).
                    // If even the block peak cannot exceed ceiling after Drive, attenuation is guaranteed 0.
                    constexpr double kEpsLinFast = 1.0e-12;
                    const double tpDbPeak   = 20.0 * std::log10 ((double) peak + kEpsLinFast);
                    const double driveDbT   = (double) driveDbSmoothed.getTargetValue();
                    const double ceilingDbT = (double) ceilingDbSmoothed.getTargetValue();

                    // Small negative margin keeps us safely on the "no GR" side.
                    if (((tpDbPeak + driveDbT) - ceilingDbT) <= -0.05)
                        skipOsFastPath = true;
                }
            }

            skipOsFastPath = false;

            if (! skipOsFastPath)
            {

            // Copy float -> double scratch (native-rate, length n)
            for (int c = 0; c < numCh; ++c)
            {
                const float* src = buffer.getReadPointer (c);
                float* dst = workBufferFloat.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = src[i];
            }

            juce::dsp::AudioBlock<float> fullBlock (workBufferFloat);
            auto blockN = fullBlock.getSubBlock (0, (size_t) n);

            juce::ScopedNoDenormals innerNoDenormals;
            auto osBlock = activeOversampler->processSamplesUp (blockN);

            const int osCh = (int) osBlock.getNumChannels();
            const int osN  = (int) osBlock.getNumSamples();

            const int osFactor = juce::jmax (1, (int) activeOversampler->getOversamplingFactor());
            const double dtOS  = lastInvSampleRate / (double) osFactor;

            // Cache oversampled channel pointers (hot path, no allocations)
            constexpr int kOsChCacheMax = 8;
            std::array<float*, (size_t) kOsChCacheMax> osPtr {};
            const int osCached = juce::jmin (juce::jmin (numCh, osCh), kOsChCacheMax);
            for (int c = 0; c < osCached; ++c)
                osPtr[(size_t) c] = osBlock.getChannelPointer ((size_t) c);

            // Phase D: materialize a fixed pointer array for the sample helper (no allocation).
            std::array<float*, (size_t) kOsChCacheMax> osPtrArr {};
            const int numChEff = juce::jmin (juce::jmin (numCh, osCh), kOsChCacheMax);
            for (int c = 0; c < numChEff; ++c)
                osPtrArr[(size_t) c] = (c < osCached ? osPtr[(size_t) c] : osBlock.getChannelPointer ((size_t) c));

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb

            


            


            // Advance smoothers at native rate (one step per native sample), reuse values across osFactor sub-samples.
            for (int iN = 0; iN < n; ++iN)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = juce::jlimit (0.0, 1.0, (double) adaptiveBias01Smoothed.getNextValue());
                const double link01    = juce::jlimit (0.0, 1.0, (double) stereoLink01Smoothed.getNextValue());

                for (int k = 0; k < osFactor; ++k)
                {
                    const int i = iN * osFactor + k;
                    if (i >= osN)
                        break;

                    processOneSample (osPtrArr.data(), numChEff, i, dtOS, driveDb, ceilingDb, bias01, link01, grDbNegMin);
                }
            }

            grDbForUI.store ((float) grDbNegMin, std::memory_order_relaxed);

            // Downsample back into blockN (workBufferFloat, native-rate length n)
            activeOversampler->processSamplesDown (blockN);

            // Copy double -> float output (native-rate)
            for (int c = 0; c < numCh; ++c)
            {
                const float* src = workBufferFloat.getReadPointer (c);
                float* dst = buffer.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = (float) src[i];
            }
            }
            else
            {
                // Deterministic advancement of smoothers (native-rate length n), with no audio-path work.
                driveDbSmoothed.skip (n);
                ceilingDbSmoothed.skip (n);
                adaptiveBias01Smoothed.skip (n);
                stereoLink01Smoothed.skip (n);

                grDbForUI.store (0.0f, std::memory_order_relaxed);
            }
        }
        else
        {
            // Native-rate fallback (prior behavior). No allocations. Deterministic.
            constexpr int kChCacheMax = 8;
            std::array<float*, (size_t) kChCacheMax> chPtr {};
            const int chCached = juce::jmin (numCh, kChCacheMax);
            for (int c = 0; c < chCached; ++c)
                chPtr[(size_t) c] = buffer.getWritePointer (c);

            // Phase D: materialize a fixed pointer array for the sample helper (no allocation).
            std::array<float*, (size_t) kChCacheMax> chPtrArr {};
            const int numChEff = juce::jmin (numCh, kChCacheMax);
            for (int c = 0; c < numChEff; ++c)
                chPtrArr[(size_t) c] = (c < chCached ? chPtr[(size_t) c] : buffer.getWritePointer (c));

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb

            


            for (int i = 0; i < n; ++i)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = juce::jlimit (0.0, 1.0, (double) adaptiveBias01Smoothed.getNextValue());
                const double link01    = juce::jlimit (0.0, 1.0, (double) stereoLink01Smoothed.getNextValue());

                processOneSample (chPtrArr.data(), numChEff, i, lastInvSampleRate, driveDb, ceilingDb, bias01, link01, grDbNegMin);
            }

            grDbForUI.store ((float) grDbNegMin, std::memory_order_relaxed);
        }
    }

    // CPU overload behavior: if we exceed a conservative share of block duration, enable assist briefly.
    {
        const auto tEnd = juce::Time::getHighResolutionTicks();
        const double elapsedSec = juce::Time::highResolutionTicksToSeconds (tEnd - tBlockStart);
        const int n = buffer.getNumSamples();
        const double blockSec = (lastSampleRate > 0.0 ? (double) n / lastSampleRate : 0.0);

        // If we're close to the deadline, disable guardrails extras for a short period.
        if (blockSec > 0.0 && elapsedSec > 0.85 * blockSec)
            overloadAssistBlocks = juce::jmax (overloadAssistBlocks, 64);

        if (overloadAssistBlocks > 0)
            --overloadAssistBlocks;
    }

    // NaN/Inf containment (release): if we tripped bad math, force safe output and reset state.
    if (badMathThisBlock)
    {
        // Force safe output (prevents explosions/ceiling risk); reset internal state so next block is stable.
        buffer.clear();

        truePeakLin = 0.0;
        microStage1DbState = { 0.0, 0.0 };
        microStage2DbState = { 0.0, 0.0 };
        macroEnergyState   = { 0.0, 0.0 };
        crestRmsSqState    = { 0.0, 0.0 };
        eventDensityState  = { 0.0, 0.0 };
        guardLpState       = { 0.0, 0.0 };
        guardTotE          = { 0.0, 0.0 };
        guardHiE           = { 0.0, 0.0 };
        lastAppliedAttnDb  = { 0.0, 0.0 };

        grDbForUI.store (0.0f, std::memory_order_relaxed);
    }

    // Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::processBlockBypassed (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // True bypass: do not touch transport/smoothers/adaptive state.
    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // Session reload must restore identical internal state.
    auto root = apvts->copyState().createXml();
    if (root == nullptr)
        root = std::make_unique<juce::XmlElement> ("PARAMS");

    auto* internal = root->createNewChildElement ("internal_state");
    internal->setAttribute ("transportKnown", (int) transportKnown);
    internal->setAttribute ("lastTransportPlaying", (int) lastTransportPlaying);

    copyXmlToBinary (*root, destData);
}

void CompassMasteringLimiterAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (xml == nullptr)
        return;

    if (xml->hasTagName (apvts->state.getType()))
        apvts->replaceState (juce::ValueTree::fromXml (*xml));
    else
        apvts->replaceState (juce::ValueTree::fromXml (*xml));

    if (auto* internal = xml->getChildByName ("internal_state"))
    {
        transportKnown = (internal->getIntAttribute ("transportKnown", 0) != 0);
        lastTransportPlaying = (internal->getIntAttribute ("lastTransportPlaying", 0) != 0);
    }
    else
    {
        transportKnown = false;
        lastTransportPlaying = false;
    }

    // Constitution: recall/reload must restore identical internal state.
    // Do not hard-reset adaptive/envelope/guard state here.
    // Sync smoothed parameters to loaded values (no ramp) to prevent discontinuities.
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}


void CompassMasteringLimiterAudioProcessor::prepareOversampling (int channels, int maxBlock)
{
    const int ch = juce::jmax (1, channels);
    const int mb = juce::jmax (1, maxBlock);

    // Prebuild 2x/4x/8x with FIR equiripple halfband filters (linear-phase).
    for (int i = 0; i < kOsCount; ++i)
    {
        const int stages = i + 1; // 1->2x, 2->4x, 3->8x
        oversamplers[(size_t) i] = std::make_unique<juce::dsp::Oversampling<float>>(
            ch,
            stages,
            juce::dsp::Oversampling<float>::filterHalfBandFIREquiripple,
            true
        );

        oversamplers[(size_t) i]->initProcessing ((size_t) mb);
        oversamplers[(size_t) i]->reset();

        oversamplerLatencySamples[(size_t) i] = oversamplers[(size_t) i]->getLatencyInSamples();
    }

    // Scratch buffer for input conversion (double precision).
    workBufferFloat.setSize (ch, mb, false, false, true);

    // Default active oversampler is 2x until boundary latch selects otherwise.
    activeOversampler = oversamplers[0].get();
    setLatencySamples (oversamplerLatencySamples[0]);
}

void CompassMasteringLimiterAudioProcessor::selectOversamplingAtBoundary (int osMinIndex) noexcept
{
    const int idx = juce::jlimit (0, kOsCount - 1, osMinIndex);
    latchedOsMinIndex = idx;

    auto* os = oversamplers[(size_t) idx].get();
    if (os != nullptr)
    {
        activeOversampler = os;
        setLatencySamples (oversamplerLatencySamples[(size_t) idx]);

        // Deterministic, transport-safe boundary behavior:
        // reset oversampler state only when latching selection (not per block).
        activeOversampler->reset();
    }
}

void CompassMasteringLimiterAudioProcessor::measureTruePeak (const juce::AudioBuffer<float>& buffer) noexcept
{
    truePeakLin = 0.0;

    if (activeOversampler == nullptr)
        return;

    const int ch = juce::jmin (workBufferFloat.getNumChannels(), buffer.getNumChannels());
    const int n  = juce::jmin (workBufferFloat.getNumSamples(),  buffer.getNumSamples());
    if (ch <= 0 || n <= 0)
        return;

    // If input is effectively silent, reset oversampler state to prevent denormal accumulation


    // in FIR filter history (common crackle source under heavy attenuation / silence).


    constexpr float kSilenceLin = 1.0e-8f;


    float inPeak = 0.0f;


    for (int c = 0; c < ch; ++c)


    {


        const float* src = buffer.getReadPointer (c);


        for (int i = 0; i < n; ++i)


        {


            const float a = std::abs (src[i]);


            if (a > inPeak) inPeak = a;


        }


    }


    if (inPeak < kSilenceLin)


    {


        truePeakLin = 0.0;


        activeOversampler->reset();


        return;


    }



    // Convert input to double for oversampled reconstruction.
    for (int c = 0; c < ch; ++c)
    {
        const float* src = buffer.getReadPointer (c);
        float* dst = workBufferFloat.getWritePointer (c);
        for (int i = 0; i < n; ++i)
            dst[i] = src[i];
    }

    juce::dsp::AudioBlock<float> block (workBufferFloat);

    juce::ScopedNoDenormals innerNoDenormals; // extra guard for oversampler internals
    auto osBlock = activeOversampler->processSamplesUp (block);

    const int osCh = (int) osBlock.getNumChannels();
    const int osN  = (int) osBlock.getNumSamples();

    for (int c = 0; c < osCh; ++c)
    {
        auto* p = osBlock.getChannelPointer ((size_t) c);
        for (int i = 0; i < osN; ++i)
        {
            const double a = std::abs (p[i]);
            if (a > truePeakLin)
                truePeakLin = a;
        }
    }

    // No downsampling/audio-path processing yet (skeleton is pass-through).

    // Diagnostic only: if near-silence, reset oversampler state to rule out denormal accumulation.
    if (truePeakLin < 1.0e-5)
        activeOversampler->reset();

    // NOTE: Do not reset per block in normal operation; true-peak reconstruction must be continuous across blocks.
}

juce::AudioProcessorEditor* CompassMasteringLimiterAudioProcessor::createEditor()
{
    return new CompassMasteringLimiterAudioProcessorEditor (*this);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CompassMasteringLimiterAudioProcessor();
}

================================================================================
FILE: Source/Plugin/PluginProcessor.h
================================================================================
#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_dsp/juce_dsp.h>
#include <array>
#include <memory>
#include <atomic>

class CompassMasteringLimiterAudioProcessor final : public juce::AudioProcessor
{
public:
    using APVTS = juce::AudioProcessorValueTreeState;

    CompassMasteringLimiterAudioProcessor();
    ~CompassMasteringLimiterAudioProcessor() override = default;

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void processBlockBypassed (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    const juce::String getName() const override { return "Compass Mastering Limiter"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    APVTS& getAPVTS() noexcept { return *apvts; }
    const APVTS& getAPVTS() const noexcept { return *apvts; }

    float getCurrentGRDb() const noexcept { return grDbForUI.load(std::memory_order_relaxed); }

private:
    static APVTS::ParameterLayout createParameterLayout();

    // Gate-3 deterministic state model:
    void reset (double sampleRate, int maxBlock, int channels) noexcept;

    // Oversampling + True Peak (Gate-4):
    // - FIR polyphase only (linear-phase reconstruction)
    // - Oversampling is prebuilt in prepareToPlay (no allocations in audio thread)
    // - Active oversampling selection changes only on transport stop/start edge
    void prepareOversampling (int channels, int maxBlock);
    void selectOversamplingAtBoundary (int osMinIndex) noexcept;
    void measureTruePeak (const juce::AudioBuffer<float>& buffer) noexcept;

    // Phase D: promoted helpers (no allocations, no virtual dispatch)
    static double onePoleAlpha (double tauSec, double dtSec) noexcept;
    void processOneSample (float* const* chPtr,
                          int numCh,
                          int i,
                          double dt,
                          double driveDb,
                          double ceilingDb,
                          double bias01,
                          double link01,
                          double& grDbNegMin) noexcept;

    // Gate-2 smoothing policy (declared now; configured in prepareToPlay/reset):
    // - Drive/Ceiling: sample-accurate linear ramps (SmoothedValue)
    // - Stereo Link / Adaptive Bias: smoothed (SmoothedValue)
    // - Oversampling Min: discrete choice (no smoothing)
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> driveDbSmoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> ceilingDbSmoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> adaptiveBias01Smoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> stereoLink01Smoothed;

    // Deterministic lifecycle context (captured in prepareToPlay/reset):
    double lastSampleRate = 0.0;
    double lastInvSampleRate = 0.0; // cached 1 / lastSampleRate (SR-derived coeff scalar)
    double effectiveControlInvDt = 0.0; // 1.0 / nativeSR
    double effectiveAudioInvDt   = 0.0; // 1.0 / (nativeSR * OSFactor); OSFactor=1.0 for now
    int lastMaxBlock = 0;
    int lastChannels = 0;

    // Transport edge detection (stop/start triggers reset semantics):
    bool transportKnown = false;
    bool lastTransportPlaying = false;

    // Oversampling (prebuilt instances; selected at transport-safe boundary only)
    static constexpr int kOsCount = 3; // 2x / 4x / 8x
    std::array<std::unique_ptr<juce::dsp::Oversampling<float>>, kOsCount> oversamplers;
    juce::dsp::Oversampling<float>* activeOversampler = nullptr;
    std::array<int, kOsCount> oversamplerLatencySamples { 0, 0, 0 };
    int latchedOsMinIndex = 0; // 0=2x, 1=4x, 2=8x (latched only at boundary)

    // Control-domain true peak (linear)
    double truePeakLin = 0.0;

    // UI meter readout (GR in dB, negative: 0..-60). Published once per block (atomic, lock-free).
    std::atomic<float> grDbForUI { 0.0f };


    // Output scalar continuity (tiny, deterministic)  prevents micro-steps reaching the output
    std::array<float, 2> lastOutScalar { 1.0f, 1.0f };
    // Guards + Safety Rails (Gate-10):
    // - Hard bounds: attenuation depth already clamped via kMaxAttnDb in processBlock
    // - Slew limiting: prevents extreme step changes from bad automation or math glitches
    std::array<double, 2> lastAppliedAttnDb { 0.0, 0.0 };

    // Tiny GR floor + hysteresis memory (per-channel) to prevent threshold chatter (observational behavior unchanged)
    std::array<double, 2> lastAttnTargetDb { 0.0, 0.0 };

    // CPU overload behavior: temporarily disable non-essential measurement extras (never changes user settings)
    int overloadAssistBlocks = 0;

    // NaN/Inf containment latch (release): if tripped, block output is forced safe and internal state resets
    bool badMathThisBlock = false;

    // Envelope system (Micro + Macro, coupled)
    // Micro: critically damped 2nd-order model (no overshoot; ultra-fast capture; no ringing)
    // Discrete-time implementation: two cascaded one-pole followers (stable for any dt; no stiffness).
    // Macro: energy accumulation + exponential decay (bounded; monotonic)
    // Coupling: macro state influences micro recovery behavior (no competing control paths)
    std::array<double, 2> microStage1DbState { 0.0, 0.0 };
    std::array<double, 2> microStage2DbState { 0.0, 0.0 };
    std::array<double, 2> macroEnergyState   { 0.0, 0.0 };

    // Gate: Adaptive Release inputs (deterministic, bounded, continuous)
    // - Crest factor proxy: short RMS energy accumulator (per-channel)
    // - Event density: continuous "event presence" accumulator (per-channel)
    std::array<double, 2> crestRmsSqState    { 0.0, 0.0 };
    std::array<double, 2> eventDensityState  { 0.0, 0.0 };

    // Spectral Guardrails (measurement-only; broadband application)
    // Parallel measurement path:
    // - frequency-selective measurement allowed
    // - must not influence detector/envelope timing/shape
    // - may only add subtle broadband GR under heavy limiting
    std::array<double, 2> guardLpState { 0.0, 0.0 }; // one-pole LP state for split
    std::array<double, 2> guardTotE   { 0.0, 0.0 }; // total energy EMA
    std::array<double, 2> guardHiE    { 0.0, 0.0 }; // high-band energy EMA

    // Scratch buffer for oversampled measurement (double precision)
    juce::AudioBuffer<float> workBufferFloat;

    std::unique_ptr<APVTS> apvts;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CompassMasteringLimiterAudioProcessor)
};

