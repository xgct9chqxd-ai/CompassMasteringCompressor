===== CompassMasteringLimiter — FULL SOURCE DUMP =====


===== FILE: Source/Plugin/PluginEditor.cpp =====

#include "PluginEditor.h"

static void setRotary (juce::Slider& s)
{
    s.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    s.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 88, 20);

    // Force visibility on dark UI (neutral, high-contrast; no "good/bad" color semantics)
    s.setColour (juce::Slider::rotarySliderOutlineColourId, juce::Colours::white.withAlpha (0.35f));
    s.setColour (juce::Slider::rotarySliderFillColourId,    juce::Colours::white.withAlpha (0.85f));
    s.setColour (juce::Slider::thumbColourId,               juce::Colours::white.withAlpha (0.90f));

    s.setColour (juce::Slider::textBoxTextColourId,         juce::Colours::white.withAlpha (0.90f));
    s.setColour (juce::Slider::textBoxOutlineColourId,      juce::Colours::white.withAlpha (0.25f));
    s.setColour (juce::Slider::textBoxBackgroundColourId,   juce::Colours::transparentBlack);
}

CompassMasteringLimiterAudioProcessorEditor::CompassMasteringLimiterAudioProcessorEditor (CompassMasteringLimiterAudioProcessor& p)
: juce::AudioProcessorEditor (&p), processor (p)
{
    setResizable (false, false);
    setSize (820, 360);

    setRotary (drive);
    addAndMakeVisible (drive);

    setRotary (ceiling);
    addAndMakeVisible (ceiling);
    adaptiveBias.addItem ("Transparent", 1);
    adaptiveBias.addItem ("Balanced", 2);
    adaptiveBias.addItem ("Aggressive", 3);
    addAndMakeVisible (adaptiveBias);

    stereoLink.setSliderStyle (juce::Slider::LinearHorizontal);
    stereoLink.setTextBoxStyle (juce::Slider::TextBoxRight, false, 90, 20);
    addAndMakeVisible (stereoLink);

    oversamplingMin.addItem ("2x", 1);
    oversamplingMin.addItem ("4x", 2);
    oversamplingMin.addItem ("8x", 3);
    addAndMakeVisible (oversamplingMin);

    addAndMakeVisible (grMeter);
    grMeter.setInterceptsMouseClicks (false, false);
    grMeter.toBack();

    currentGrLabel.setJustificationType (juce::Justification::centredRight);
    currentGrLabel.setFont (juce::Font (14.0f));
    currentGrLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    currentGrLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    currentGrLabel.setInterceptsMouseClicks (false, false);
    currentGrLabel.setText ("0.0 dB", juce::dontSendNotification);
    addAndMakeVisible (currentGrLabel);

    inTpLabel.setJustificationType (juce::Justification::centredLeft);
    inTpLabel.setFont (juce::Font (13.0f));
    inTpLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    inTpLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    inTpLabel.setInterceptsMouseClicks (false, false);
    inTpLabel.setText ("IN TP: -120.0 dBTP", juce::dontSendNotification);
    addAndMakeVisible (inTpLabel);

    outTpLabel.setJustificationType (juce::Justification::centredLeft);
    outTpLabel.setFont (juce::Font (13.0f));
    outTpLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    outTpLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    outTpLabel.setInterceptsMouseClicks (false, false);
    outTpLabel.setText ("OUT TP: -120.0 dBTP", juce::dontSendNotification);
    addAndMakeVisible (outTpLabel);

    lufsSLabel.setJustificationType (juce::Justification::centredLeft);
    lufsSLabel.setFont (juce::Font (13.0f));
    lufsSLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    lufsSLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    lufsSLabel.setInterceptsMouseClicks (false, false);
    lufsSLabel.setText ("LUFS-S: -120.0", juce::dontSendNotification);
    addAndMakeVisible (lufsSLabel);

    lufsILabel.setJustificationType (juce::Justification::centredLeft);
    lufsILabel.setFont (juce::Font (13.0f));
    lufsILabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    lufsILabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    lufsILabel.setInterceptsMouseClicks (false, false);
    lufsILabel.setText ("LUFS-I: -120.0", juce::dontSendNotification);
    addAndMakeVisible (lufsILabel);

    inPeakLabel.setJustificationType (juce::Justification::centredLeft);
    inPeakLabel.setFont (juce::Font (13.0f));
    inPeakLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    inPeakLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    inPeakLabel.setInterceptsMouseClicks (false, false);
    inPeakLabel.setText ("IN PEAK: -120.0 dBFS", juce::dontSendNotification);
    addAndMakeVisible (inPeakLabel);

    outPeakLabel.setJustificationType (juce::Justification::centredLeft);
    outPeakLabel.setFont (juce::Font (13.0f));
    outPeakLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    outPeakLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    outPeakLabel.setInterceptsMouseClicks (false, false);
    outPeakLabel.setText ("OUT PEAK: -120.0 dBFS", juce::dontSendNotification);
    addAndMakeVisible (outPeakLabel);

    ceilingLabel.setJustificationType (juce::Justification::centredLeft);
    ceilingLabel.setFont (juce::Font (13.0f));
    ceilingLabel.setColour (juce::Label::textColourId, juce::Colours::white.withAlpha (0.70f));
    ceilingLabel.setColour (juce::Label::backgroundColourId, juce::Colours::transparentBlack);
    ceilingLabel.setInterceptsMouseClicks (false, false);
    ceilingLabel.setText ("CEILING: -1.0 dBTP", juce::dontSendNotification);
    addAndMakeVisible (ceilingLabel);

    auto& vts = processor.getAPVTS();

    driveA   = std::make_unique<APVTS::SliderAttachment> (vts, "drive", drive);
    ceilingA = std::make_unique<APVTS::SliderAttachment> (vts, "ceiling", ceiling);
    biasA    = std::make_unique<APVTS::ComboBoxAttachment> (vts, "adaptive_bias", adaptiveBias);
    linkA    = std::make_unique<APVTS::SliderAttachment> (vts, "stereo_link", stereoLink);
    osA      = std::make_unique<APVTS::ComboBoxAttachment> (vts, "oversampling_min", oversamplingMin);

    startTimerHz (30);
}

void CompassMasteringLimiterAudioProcessorEditor::timerCallback()
{
    const float current = processor.getCurrentGRDb();

    grMeter.pushValueDb (current);
    currentGrLabel.setText (juce::String::formatted ("%.1f dB", current), juce::dontSendNotification);

    float inTp = -120.0f;
    float outTp = -120.0f;
    if (processor.getCurrentTruePeakDbTP (inTp, outTp))
    {
        inTp = juce::jmax (-120.0f, inTp);
        outTp = juce::jmax (-120.0f, outTp);
        inTpLabel.setText (juce::String::formatted ("IN TP: %.1f dBTP", inTp), juce::dontSendNotification);
        outTpLabel.setText (juce::String::formatted ("OUT TP: %.1f dBTP", outTp), juce::dontSendNotification);
    }

    float lufsS = -120.0f;
    float lufsI = -120.0f;
    if (processor.getCurrentLufsDb (lufsS, lufsI))
    {
        lufsS = juce::jmax (-120.0f, lufsS);
        lufsI = juce::jmax (-120.0f, lufsI);
        lufsSLabel.setText (juce::String::formatted ("LUFS-S: %.1f", lufsS), juce::dontSendNotification);
        lufsILabel.setText (juce::String::formatted ("LUFS-I: %.1f", lufsI), juce::dontSendNotification);
    }

    float inPk = -120.0f;
    float outPk = -120.0f;
    if (processor.getCurrentPeakDbFS (inPk, outPk))
    {
        inPk = juce::jmax (-120.0f, inPk);
        outPk = juce::jmax (-120.0f, outPk);
        inPeakLabel.setText (juce::String::formatted ("IN PEAK: %.1f dBFS", inPk), juce::dontSendNotification);
        outPeakLabel.setText (juce::String::formatted ("OUT PEAK: %.1f dBFS", outPk), juce::dontSendNotification);
    }

    const float ceilDb = processor.getCurrentCeilingDbTP();
    ceilingLabel.setText (juce::String::formatted ("CEILING: %.1f dBTP", ceilDb), juce::dontSendNotification);

    grMeter.repaint();
}

void CompassMasteringLimiterAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);

    // Title
    g.setColour (juce::Colours::white.withAlpha (0.85f));
    g.setFont (14.0f);
    g.drawText ("Compass Mastering Limiter", 16, 10, getWidth() - 32, 20, juce::Justification::left);

    // Static labels (constitution: labeling for all visible controls)
    auto drawLabelAbove = [&] (const juce::Component& c, const juce::String& label)
    {
        auto r = c.getBounds().translated (0, -18);
        r.setHeight (16);
        g.setColour (juce::Colours::white.withAlpha (0.70f));
        g.setFont (12.5f);
        g.drawText (label, r, juce::Justification::centred, false);
    };

    drawLabelAbove (drive,           "Drive");
    drawLabelAbove (ceiling,         "Ceiling");
    drawLabelAbove (adaptiveBias,    "Adaptive Bias");
    drawLabelAbove (stereoLink,      "Stereo Link");
    drawLabelAbove (oversamplingMin, "Oversampling Min");
}

void CompassMasteringLimiterAudioProcessorEditor::resized()
{
    auto b = getLocalBounds().reduced (16);
    b.removeFromTop (30);

    const int knob = 104;
    const int gap  = 16;

    auto row = b.removeFromTop (knob + 30);

    drive.setBounds (row.removeFromLeft (knob));
    row.removeFromLeft (gap);
    ceiling.setBounds (row.removeFromLeft (knob));
    row.removeFromLeft (gap);

    adaptiveBias.setBounds (row.removeFromLeft (260).withTrimmedTop (34).withHeight (26));
    row.removeFromLeft (gap);
    stereoLink.setBounds (row.removeFromLeft (260).withTrimmedTop (34).withHeight (26));
    row.removeFromLeft (gap);
    oversamplingMin.setBounds (row.removeFromLeft (100).withTrimmedTop (34).withHeight (26));

    b.removeFromTop (10);

    // Primary meter zone (Verification): GR bar + numeric, then truth readouts below.
    const int grH     = 32;
    const int colW    = 220;
    const int padX    = 10;
    const int rowH    = 18;
    const int rowGap  = 6;
    const int topGap  = 10;

    const int truthH  = (rowH * 4) + (rowGap * 3);   // 4 rows: TP, LUFS, PEAK, CEILING
    const int zoneH   = grH + topGap + truthH;

    auto meterZone = b.removeFromTop (zoneH);

    grMeter.setBounds (meterZone.removeFromTop (grH));
    auto m = grMeter.getBounds();

    // GR numeric (right side of the bar zone)
    currentGrLabel.setBounds (m.getRight() - 90, m.getY() + 6, 84, 18);

    // Truth readouts grid (2-column, multi-row)
    const int leftX  = m.getX() + padX;
    const int rightX = m.getRight() - colW - padX;

    const int y1 = meterZone.getY() + 6;             // Row 1
    const int y2 = y1 + rowH + rowGap;               // Row 2
    const int y3 = y2 + rowH + rowGap;               // Row 3
    const int y4 = y3 + rowH + rowGap;               // Row 4 (Ceiling)

    // Row 1: IN/OUT TP
    inTpLabel.setBounds  (leftX,  y1, colW, rowH);
    outTpLabel.setBounds (rightX, y1, colW, rowH);

    // Row 2: LUFS-S / LUFS-I
    lufsSLabel.setBounds (leftX,  y2, colW, rowH);
    lufsILabel.setBounds (rightX, y2, colW, rowH);

    // Row 3: IN/OUT PEAK
    inPeakLabel.setBounds  (leftX,  y3, colW, rowH);
    outPeakLabel.setBounds (rightX, y3, colW, rowH);

    // Row 4: CEILING (full width)
    ceilingLabel.setBounds (m.getX() + padX, y4, m.getWidth() - (2 * padX), rowH);
}

===== FILE: Source/Plugin/PluginEditor.h =====

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <cmath>
#include "PluginProcessor.h"

class GRHistoryMeter final : public juce::Component
{
public:
    void pushValueDb (float grDb) noexcept
    {
        if (! std::isfinite (grDb)) grDb = 0.0f;

        // UI contract: GR is stereo authority in positive dB (0..range).
        constexpr float kRangeDb = 24.0f;
        lastGrDb = juce::jlimit (0.0f, kRangeDb, grDb);
    }

    void paint (juce::Graphics& g) override
    {
        auto r = getLocalBounds().toFloat().reduced (6.0f);

        // Background
        g.setColour (juce::Colours::white.withAlpha (0.10f));
        g.fillRoundedRectangle (r, 8.0f);

        // Filled bar (left -> right as GR increases)
        constexpr float kRangeDb = 24.0f;
        const float fill01 = juce::jlimit (0.0f, 1.0f, lastGrDb / kRangeDb);
        auto fillR = r;
        fillR.setWidth (r.getWidth() * fill01);

        g.setColour (juce::Colours::white.withAlpha (0.60f));
        g.fillRoundedRectangle (fillR, 8.0f);

        // Label "GR"
        auto labelR = r.reduced (10.0f, 6.0f);
        g.setColour (juce::Colours::white.withAlpha (0.70f));
        g.setFont (12.5f);
        g.drawText ("GR", labelR.removeFromLeft (34.0f), juce::Justification::centredLeft, false);
    }

private:
    float lastGrDb = 0.0f;
};

class CompassMasteringLimiterAudioProcessorEditor final
    : public juce::AudioProcessorEditor
    , private juce::Timer
{
public:
    explicit CompassMasteringLimiterAudioProcessorEditor (CompassMasteringLimiterAudioProcessor&);
    ~CompassMasteringLimiterAudioProcessorEditor() override = default;

    void paint (juce::Graphics&) override;
    void resized() override;

private:
    void timerCallback() override;

    CompassMasteringLimiterAudioProcessor& processor;

    juce::Slider drive;
    juce::Slider ceiling;
    juce::ComboBox adaptiveBias;
    juce::Slider stereoLink;
    juce::ComboBox oversamplingMin;

    GRHistoryMeter grMeter;
    juce::Label currentGrLabel;
    juce::Label inTpLabel;
    juce::Label outTpLabel;
    juce::Label lufsSLabel;
    juce::Label lufsILabel;

    juce::Label inPeakLabel;
    juce::Label outPeakLabel;
    juce::Label ceilingLabel;

    using APVTS = juce::AudioProcessorValueTreeState;
    std::unique_ptr<APVTS::SliderAttachment> driveA;
    std::unique_ptr<APVTS::SliderAttachment> ceilingA;
    std::unique_ptr<APVTS::ComboBoxAttachment> biasA;
    std::unique_ptr<APVTS::SliderAttachment> linkA;
    std::unique_ptr<APVTS::ComboBoxAttachment> osA;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CompassMasteringLimiterAudioProcessorEditor)
};

===== FILE: Source/Plugin/PluginProcessor.cpp =====

#include "PluginProcessor.h"
#include "PluginEditor.h"

CompassMasteringLimiterAudioProcessor::CompassMasteringLimiterAudioProcessor()
: juce::AudioProcessor (BusesProperties()
#if ! JucePlugin_IsMidiEffect
 #if ! JucePlugin_IsSynth
    .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
 #endif
    .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
#endif
)
{
    apvts = std::make_unique<APVTS>(*this, nullptr, "PARAMS", createParameterLayout());
}

CompassMasteringLimiterAudioProcessor::APVTS::ParameterLayout
CompassMasteringLimiterAudioProcessor::createParameterLayout()
{
    APVTS::ParameterLayout layout;

    // IDs are constitution-locked (no aliases, no hidden controls)
    // Value ranges are defined exactly per Gate-2 spec.
    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "drive", 1 },
        "Drive",
        juce::NormalisableRange<float> { 0.0f, 20.0f, 0.01f },
        0.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dB"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "ceiling", 1 },
        "Ceiling",
        juce::NormalisableRange<float> { -6.0f, 0.0f, 0.01f },
        -0.3f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dBTP"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "adaptive_bias", 1 },
        "Adaptive Bias",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.5f },
        0.5f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int)
        {
            // Constitution: continuous scalar with discrete UI labels mapped to fixed scalar points.
            // Enforced scalar points: 0.0=Transparent, 0.5=Balanced, 1.0=Aggressive
            if (v <= 0.25f) return juce::String ("Transparent");
            if (v >= 0.75f) return juce::String ("Aggressive");
            return juce::String ("Balanced");
        },
        [] (const juce::String& s)
        {
            if (s.equalsIgnoreCase ("Transparent")) return 0.0f;
            if (s.equalsIgnoreCase ("Balanced"))    return 0.5f;
            if (s.equalsIgnoreCase ("Aggressive"))  return 1.0f;

            const float v = s.getFloatValue();
            const float vc = juce::jlimit (0.0f, 1.0f, v);
            const float snapped = std::round (vc * 2.0f) * 0.5f; // -> {0.0, 0.5, 1.0}
            return juce::jlimit (0.0f, 1.0f, snapped);
        }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "stereo_link", 1 },
        "Stereo Link",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v * 100.0f, 1) + " %"; },
        [] (const juce::String& s) { return s.getFloatValue() / 100.0f; }
    ));

    layout.add (std::make_unique<juce::AudioParameterChoice>(
        juce::ParameterID { "oversampling_min", 1 },
        "Oversampling Min",
        juce::StringArray { "2x", "4x", "8x" },
        0
    ));

    return layout;
}

void CompassMasteringLimiterAudioProcessor::reset (double sampleRate, int maxBlock, int channels) noexcept
{
    lastSampleRate = (sampleRate > 0.0 ? sampleRate : 44100.0);
    lastInvSampleRate = 1.0 / juce::jmax (1.0, lastSampleRate);
    effectiveControlInvDt = lastInvSampleRate;
    effectiveAudioInvDt   = lastInvSampleRate; // OSFactor=1.0 until oversampled audio-path processing is introduced
    lastMaxBlock   = (maxBlock > 0 ? maxBlock : 0);
    lastChannels   = (channels > 0 ? channels : 0);

    // Phase 11 — Metering Plumbing: deterministic meter timing + accumulator reset (single source of truth).
    meterDt = 1.0 / lastSampleRate;
    meterPublishSamples = (int) juce::jmax (1.0, lastSampleRate / 50.0); // 50 Hz, clamped
    meterCountdown = meterPublishSamples;

    for (int c = 0; c < 2; ++c)
    {
        inPeakHold[c]  = 0.0;
        outPeakHold[c] = 0.0;
        inRmsSq[c]     = 0.0;
        outRmsSq[c]    = 0.0;
        inTpHold[c]    = 0.0;
        outTpHold[c]   = 0.0;
        grHoldDb[c]    = 0.0;
    }

    // Loudness reset (deterministic; bounded; allocation-free).
    lufsChunkE.fill (0.0);
    lufsChunkWrite  = 0u;
    lufsChunkFilled = 0u;
    lufsShortSumE   = 0.0;
    lufsCurChunkE   = 0.0;
    lufsCurChunkN   = 0;
    lufsIntSumE     = 0.0;
    lufsIntN        = 0u;

    // Publication bookkeeping reset (deterministic; lock-free). Do NOT clear meterRing here (reset() may run on audio thread).
    meterWriteIndex.store (0u, std::memory_order_relaxed);
    meterReadIndex.store  (0u, std::memory_order_relaxed);
    meterSeq.store        (0u, std::memory_order_relaxed);
    meterLastReadSeq.store(0u, std::memory_order_relaxed);

    // Deterministic reset of adaptive/envelope/guard state:
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.reset (lastSampleRate, 0.020);        // 20 ms
    ceilingDbSmoothed.reset (lastSampleRate, 0.020);      // 20 ms
    adaptiveBias01Smoothed.reset (lastSampleRate, 0.050); // 50 ms
    stereoLink01Smoothed.reset (lastSampleRate, 0.050);   // 50 ms

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);

    // Envelope state reset (deterministic; bounded)
    microStage1DbState = { 0.0, 0.0 };
    microStage2DbState = { 0.0, 0.0 };
    macroEnergyState   = { 0.0, 0.0 };

    lastAttnTargetDb   = { 0.0, 0.0 };
    lastAppliedAttnDb  = { 0.0, 0.0 };

    // Spectral Guardrails state (measurement-only)
    guardLpState = { 0.0, 0.0 };
    guardTotE    = { 0.0, 0.0 };
    guardHiE     = { 0.0, 0.0 };
    crestRmsSqState    = { 0.0, 0.0 };
    eventDensityState  = { 0.0, 0.0 };

    lastOutScalar = { 1.0f, 1.0f };
}

void CompassMasteringLimiterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
    reset (sampleRate, samplesPerBlock, ch);

    // Optional deterministic ring init (fixed-size, outside audio thread).
    // This is allowed here (prepareToPlay is not the audio callback boundary).
    meterRing.fill (MeterSnapshot {});

    // Prebuild oversampling instances (no allocations in audio thread).
    prepareOversampling (ch, samplesPerBlock);

    // Latch initial oversampling selection (treated as transport-safe init).
    const int osMinIndex = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    selectOversamplingAtBoundary (osMinIndex);

    // Transport becomes unknown on prepare (hosts differ); edge detection begins on first block.
    transportKnown = false;
    lastTransportPlaying = false;
}

void CompassMasteringLimiterAudioProcessor::releaseResources()
{

    // Phase 11 — Metering Plumbing: deterministic teardown reset (no SR math here).
    meterPublishSamples = 0;
    meterCountdown      = 0;
    meterDt             = 0.0;

    for (int c = 0; c < 2; ++c)
    {
        inPeakHold[c]  = 0.0;
        outPeakHold[c] = 0.0;
        inRmsSq[c]     = 0.0;
        outRmsSq[c]    = 0.0;
        inTpHold[c]    = 0.0;
        outTpHold[c]   = 0.0;
        grHoldDb[c]    = 0.0;
    }

    meterWriteIndex.store (0u, std::memory_order_relaxed);
    meterReadIndex.store  (0u, std::memory_order_relaxed);
    meterSeq.store        (0u, std::memory_order_relaxed);
    meterLastReadSeq.store(0u, std::memory_order_relaxed);

}

bool CompassMasteringLimiterAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (! out.isDisabled());
}


double CompassMasteringLimiterAudioProcessor::onePoleAlpha (double tauSec, double dtSec) noexcept
{
    return std::exp (-dtSec / juce::jmax (1.0e-9, tauSec));
}

void CompassMasteringLimiterAudioProcessor::processOneSample (float* const* chPtr,
                                                             int numCh,
                                                             int i,
                                                             double dt,
                                                             double driveDb,
                                                             double ceilingDb,
                                                             double bias01,
                                                             double link01,
                                                             double& grDbNegMin) noexcept
{
    // Softplus controls (smooth, monotonic, branch-free)
    constexpr double kEpsLin    = 1.0e-12; // avoids log(0)
    constexpr double kSoftK     = 32.0;
    constexpr double kMaxAttnDb = 120.0;

    // Time constants (seconds). Names avoid forbidden terminology.
    constexpr double kMacroSecBase = 0.1200; // 120 ms nominal

    std::array<double, 2> attnDbCh { 0.0, 0.0 };

    // Spectral Guardrails: parallel measurement (no influence on envelope)
    constexpr double kGuardFcHz   = 4500.0;
    constexpr double kGuardTauSec = 0.040;
    const double gGuardLp = std::exp (-2.0 * juce::MathConstants<double>::pi * kGuardFcHz * dt);
    const double aGuardE  = onePoleAlpha (kGuardTauSec, dt);

    const int chProc = juce::jmin (2, numCh);
    double guardrailHf01 = 0.0;

    const bool overloadAssistOn = (overloadAssistBlocks > 0);

    for (int c = 0; c < chProc; ++c)
    {
        const double s = (double) chPtr[c][i];

        // Step 4 — Compute Input peak + RMS (broadband), linear domain (no dB).
        // Guard: accumulators are 2ch; never index beyond [0..1].
        if (c < 2)
        {
            const double inAbs = std::abs (s);
            inPeakHold[(size_t) c] = juce::jmax (inPeakHold[(size_t) c], inAbs);
            inRmsSq[(size_t) c] += (inAbs * inAbs);
        }

        if (! overloadAssistOn)
        {
            const double lp = gGuardLp * guardLpState[(size_t) c] + (1.0 - gGuardLp) * s;
            guardLpState[(size_t) c] = lp;
            const double hp = s - lp;

            const double s2  = s  * s;
            const double hp2 = hp * hp;

            guardTotE[(size_t) c] = aGuardE * guardTotE[(size_t) c] + (1.0 - aGuardE) * s2;
            guardHiE[(size_t) c]  = aGuardE * guardHiE[(size_t) c]  + (1.0 - aGuardE) * hp2;

            const double denom = guardTotE[(size_t) c] + 1.0e-18;
            const double hf = juce::jlimit (0.0, 1.0, guardHiE[(size_t) c] / denom);
            if (hf > guardrailHf01) guardrailHf01 = hf;
        }

        const double tpDb = 20.0 * std::log10 (std::abs (s) + kEpsLin);

        const double x = (tpDb + driveDb) - ceilingDb;

        const double z = kSoftK * x;
        const double softplus = z + std::log1p (std::exp (-std::abs (z)));
        double attnTargetDb = softplus / kSoftK;
        attnTargetDb = juce::jlimit (0.0, kMaxAttnDb, attnTargetDb);

        constexpr double kGrFloorDb    = 0.05;
        constexpr double kHysteresisDb = 0.08;

        double currentTarget = attnTargetDb;
        if (currentTarget < kGrFloorDb)
            currentTarget = 0.0;
        else if (currentTarget < lastAttnTargetDb[(size_t) c] + kHysteresisDb)
            currentTarget = lastAttnTargetDb[(size_t) c];

        lastAttnTargetDb[(size_t) c] = currentTarget;
        attnTargetDb = currentTarget;

        const double energyInput = juce::jmax (0.0, std::pow (10.0, attnTargetDb / 20.0) - 1.0);

        const double macroSec = kMacroSecBase * (1.20 - 0.40 * bias01);
        const double aM = onePoleAlpha (macroSec, dt);
        macroEnergyState[(size_t) c] = aM * macroEnergyState[(size_t) c] + (1.0 - aM) * energyInput;

        const double macro01 = macroEnergyState[(size_t) c] / (1.0 + macroEnergyState[(size_t) c]);
        const double sustained01 = juce::jlimit (0.0, 1.0, macro01);

        constexpr double kCrestRmsSecBase = 0.050;
        const double crestRmsSec = kCrestRmsSecBase * (1.15 - 0.30 * bias01);
        const double aCR = onePoleAlpha (crestRmsSec, dt);
        const double absS = std::abs (s);
        crestRmsSqState[(size_t) c] = aCR * crestRmsSqState[(size_t) c] + (1.0 - aCR) * (absS * absS);
        const double rmsLin = std::sqrt (juce::jmax (0.0, crestRmsSqState[(size_t) c]));
        const double crest = absS / (rmsLin + 1.0e-12);
        const double crest01 = juce::jlimit (0.0, 1.0, (crest - 1.0) / (crest + 1.0));

        constexpr double kDensitySecBase = 0.090;
        const double densitySec = kDensitySecBase * (1.20 - 0.40 * bias01);
        const double aD = onePoleAlpha (densitySec, dt);
        const double densityInput = 1.0 - std::exp (-0.18 * attnTargetDb);
        eventDensityState[(size_t) c] = aD * eventDensityState[(size_t) c] + (1.0 - aD) * densityInput;
        const double density01 = juce::jlimit (0.0, 1.0, eventDensityState[(size_t) c]);

        constexpr double kMicroSecMin = 0.0030;
        constexpr double kMicroSecMax = 0.0600;

        const double hold01 = juce::jlimit (0.0, 1.0,
            (0.60 + 0.20 * (1.0 - bias01)) * sustained01 +
            (0.40 - 0.20 * (1.0 - bias01)) * density01);

        const double snap01 = crest01;

        const double resp01 = juce::jlimit (0.0, 1.0,
            (0.45 + 0.35 * bias01) * snap01 +
            (0.55 - 0.35 * bias01) * (1.0 - hold01));

        const double microSec = kMicroSecMin + (kMicroSecMax - kMicroSecMin) * (1.0 - resp01);

        const double aU = onePoleAlpha (microSec, dt);

        microStage1DbState[(size_t) c] = aU * microStage1DbState[(size_t) c] + (1.0 - aU) * attnTargetDb;
        microStage2DbState[(size_t) c] = aU * microStage2DbState[(size_t) c] + (1.0 - aU) * microStage1DbState[(size_t) c];

        double y1 = microStage2DbState[(size_t) c];
        y1 = juce::jlimit (0.0, kMaxAttnDb, y1);
        microStage2DbState[(size_t) c] = y1;

        attnDbCh[(size_t) c] = y1;
    }

    if (numCh > 2)
    {
        for (int c = 2; c < numCh; ++c)
            attnDbCh[1] = juce::jmax (attnDbCh[1], attnDbCh[0]);
    }

    const double linkedDb = juce::jmax (attnDbCh[0], attnDbCh[1]);
    const double outDbL0 = (1.0 - link01) * attnDbCh[0] + link01 * linkedDb;
    const double outDbR0 = (1.0 - link01) * attnDbCh[1] + link01 * linkedDb;

    double outDbL = outDbL0;
    double outDbR = outDbR0;
    {
        const double grAbsDb = juce::jmax (outDbL, outDbR);

        constexpr double kGuardOnDb       = 3.0;
        constexpr double kGuardFullDb     = 12.0;
        constexpr double kGuardMaxExtraDb = 1.2;

        double t = 0.0;
        if (grAbsDb > kGuardOnDb)
            t = juce::jlimit (0.0, 1.0, (grAbsDb - kGuardOnDb) / (kGuardFullDb - kGuardOnDb));

        const double tSmooth = t * t * (3.0 - 2.0 * t);

        const double hf01 = juce::jlimit (0.0, 1.0, guardrailHf01);
        const double guardDb = juce::jlimit (0.0, kGuardMaxExtraDb, tSmooth * hf01 * kGuardMaxExtraDb);

        outDbL += guardDb;
        outDbR += guardDb;
    }

    outDbL = juce::jlimit (0.0, kMaxAttnDb, outDbL);
    outDbR = juce::jlimit (0.0, kMaxAttnDb, outDbR);

    constexpr double kTinyGrDb = 0.03;
    if (outDbL < kTinyGrDb) outDbL = 0.0;
    if (outDbR < kTinyGrDb) outDbR = 0.0;

    constexpr double kMaxSlewDbPerSec = 600.0;
    const double maxDeltaDb = kMaxSlewDbPerSec * dt;

    const double prevL = lastAppliedAttnDb[0];
    const double prevR = lastAppliedAttnDb[1];

    outDbL = juce::jlimit (prevL - maxDeltaDb, prevL + maxDeltaDb, outDbL);
    outDbR = juce::jlimit (prevR - maxDeltaDb, prevR + maxDeltaDb, outDbR);

    lastAppliedAttnDb[0] = outDbL;
    lastAppliedAttnDb[1] = outDbR;

    if (numCh >= 1 && std::isfinite (outDbL))
    {
        const double grThisDb = juce::jlimit (0.0, 120.0, outDbL);
        grHoldDb[0] = juce::jmax (grHoldDb[0], grThisDb);
    }

    if (numCh >= 2 && std::isfinite (outDbR))
    {
        const double grThisDb = juce::jlimit (0.0, 120.0, outDbR);
        grHoldDb[1] = juce::jmax (grHoldDb[1], grThisDb);
    }

    if (! std::isfinite (outDbL) || ! std::isfinite (outDbR))
        badMathThisBlock = true;

    const double grDbNeg = -juce::jmax (outDbL, outDbR);
    if (grDbNeg < grDbNegMin)
        grDbNegMin = grDbNeg;

    const float gL0 = (float) std::pow (10.0, -outDbL / 20.0);
    const float gR0 = (float) std::pow (10.0, -outDbR / 20.0);

    constexpr double kOutTauSec = 0.005;
    const float aOut = (float) onePoleAlpha (kOutTauSec, dt);
    const float gL = lastOutScalar[0] * aOut + gL0 * (1.0f - aOut);
    const float gR = lastOutScalar[1] * aOut + gR0 * (1.0f - aOut);
    lastOutScalar[0] = gL;
    lastOutScalar[1] = gR;

    constexpr float kEpsAbs = 1.0e-12f;
    float ceilingLin = (float) std::pow (10.0, ceilingDb / 20.0);
    if (! std::isfinite ((double) ceilingLin) || ceilingLin <= 0.0f)
        ceilingLin = 0.0f;

    if (numCh >= 1)
    {
        float x = chPtr[0][i];
        if (! std::isfinite ((double) x)) x = 0.0f;

        const float a = std::abs (x);
        const float gCeil = (a > kEpsAbs ? (ceilingLin / a) : 1.0e12f);
        const float gApplied = (gL < gCeil ? gL : gCeil);

        float y = x * gApplied;
        if (! std::isfinite ((double) y)) y = 0.0f;
        chPtr[0][i] = y;
    }

    if (numCh >= 2)
    {
        float x = chPtr[1][i];
        if (! std::isfinite ((double) x)) x = 0.0f;

        const float a = std::abs (x);
        const float gCeil = (a > kEpsAbs ? (ceilingLin / a) : 1.0e12f);
        const float gApplied = (gR < gCeil ? gR : gCeil);

        float y = x * gApplied;
        if (! std::isfinite ((double) y)) y = 0.0f;
        chPtr[1][i] = y;
    }

    for (int c = 2; c < numCh; ++c)
    {
        float x = chPtr[c][i];
        if (! std::isfinite ((double) x)) x = 0.0f;

        const float a = std::abs (x);
        const float gCeil = (a > kEpsAbs ? (ceilingLin / a) : 1.0e12f);
        const float gApplied = (gR < gCeil ? gR : gCeil);

        float y = x * gApplied;
        if (! std::isfinite ((double) y)) y = 0.0f;
        chPtr[c][i] = y;
    }

    // Step 4 — Compute Output peak + RMS (broadband), linear domain (no dB).
    // Guard: accumulators are 2ch; never index beyond [0..1].
    const int chProcOut = juce::jmin (2, numCh);
    for (int c = 0; c < chProcOut; ++c)
    {
        const double y = (double) chPtr[c][i];
        const double outAbs = std::abs (y);
        outPeakHold[(size_t) c] = juce::jmax (outPeakHold[(size_t) c], outAbs);
        outRmsSq[(size_t) c] += (outAbs * outAbs);
    }
}

// Phase 11 — Metering Plumbing: publishMeters (SPSC ring producer)
void CompassMasteringLimiterAudioProcessor::publishMeters (const MeterSnapshot& s) noexcept
{
    const uint32_t w = meterWriteIndex.load (std::memory_order_relaxed);

    meterRing[(size_t) w] = s;

    const uint32_t wNext = (w + 1u) % kMeterRingCapacity;
    const uint32_t r     = meterReadIndex.load (std::memory_order_relaxed);

    if (wNext == r)
    {
        const uint32_t rNext = (r + 1u) % kMeterRingCapacity;
        meterReadIndex.store (rNext, std::memory_order_relaxed);
    }

    meterWriteIndex.store (wNext, std::memory_order_relaxed);

    meterSeq.fetch_add (1u, std::memory_order_release);
}

bool CompassMasteringLimiterAudioProcessor::readMeters (MeterSnapshot& out) const noexcept
{
    const uint32_t seqNow  = meterSeq.load (std::memory_order_acquire);
    const uint32_t seqPrev = meterLastReadSeq.load (std::memory_order_relaxed);

    if (seqNow == seqPrev)
        return false;

    const uint32_t w = meterWriteIndex.load (std::memory_order_relaxed);
    const uint32_t idx = (w + kMeterRingCapacity - 1u) % kMeterRingCapacity;

    out = meterRing[(size_t) idx];

    meterLastReadSeq.store (seqNow, std::memory_order_relaxed);

    // Latest-snapshot policy: advance consumer index to keep producer's "ring full" test sane.
    meterReadIndex.store (w, std::memory_order_relaxed);

    return true;
}

void CompassMasteringLimiterAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals denormGuard;

    // FTZ/DAZ always on (JUCE-supported): prevents denormal CPU spikes on silence/tails.
    juce::FloatVectorOperations::disableDenormalisedNumberSupport (true);

    // NaN/Inf containment helpers
    auto isBadF = [] (float x) noexcept { return ! std::isfinite (x); };
    auto isBadD = [] (double x) noexcept { return ! std::isfinite (x); };

    badMathThisBlock = false;

   #if JUCE_DEBUG
    // Debug asserts for internal state invariants
    jassert (std::isfinite (truePeakLin));
    jassert (std::isfinite (microStage1DbState[0]) && std::isfinite (microStage1DbState[1]));
    jassert (std::isfinite (microStage2DbState[0]) && std::isfinite (microStage2DbState[1]));
    jassert (std::isfinite (macroEnergyState[0])   && std::isfinite (macroEnergyState[1]));
   #endif

    // Release containment: sanitize any bad carried state immediately (prevents propagation)
    if (isBadD (truePeakLin) ||
        isBadD (microStage1DbState[0]) || isBadD (microStage1DbState[1]) ||
        isBadD (microStage2DbState[0]) || isBadD (microStage2DbState[1]) ||
        isBadD (macroEnergyState[0])   || isBadD (macroEnergyState[1]))
    {
        truePeakLin = 0.0;
        microStage1DbState = { 0.0, 0.0 };
        microStage2DbState = { 0.0, 0.0 };
        macroEnergyState   = { 0.0, 0.0 };
        crestRmsSqState    = { 0.0, 0.0 };
        eventDensityState  = { 0.0, 0.0 };
        guardLpState       = { 0.0, 0.0 };
        guardTotE          = { 0.0, 0.0 };
        guardHiE           = { 0.0, 0.0 };
        lastAppliedAttnDb  = { 0.0, 0.0 };
    }

    // Gate-3 deterministic transport semantics:
    // transport stop/start resets adaptive/envelope/guard states and is the only safe boundary for oversampling selection.
    if (auto* ph = getPlayHead())
    {
        juce::AudioPlayHead::CurrentPositionInfo pos;
        if (ph->getCurrentPosition (pos))
        {
            const bool playingNow = pos.isPlaying;
            if (! transportKnown)
            {
                transportKnown = true;
                lastTransportPlaying = playingNow;
            }
            else if (playingNow != lastTransportPlaying)
            {
                lastTransportPlaying = playingNow;

                const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
                reset (lastSampleRate, lastMaxBlock, ch);

                // Transport-safe boundary: latch oversampling selection (no allocations here).
                const int osMinIndexBoundary = (int) apvts->getRawParameterValue ("oversampling_min")->load();
                selectOversamplingAtBoundary (osMinIndexBoundary);
            }
        }
    }

    // Gate-2 rule: read params once per block into locals (atomics -> locals).
    const float driveDbTarget   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDbTarget = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01Target    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01Target    = apvts->getRawParameterValue ("stereo_link")->load();
    const int   osMinIndex      = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    juce::ignoreUnused (osMinIndex);

    driveDbSmoothed.setTargetValue (driveDbTarget);
    ceilingDbSmoothed.setTargetValue (ceilingDbTarget);
    adaptiveBias01Smoothed.setTargetValue (bias01Target);
    stereoLink01Smoothed.setTargetValue (link01Target);

    const auto tBlockStart = juce::Time::getHighResolutionTicks();

    // Control-domain true peak measurement disabled in Phase0 (buffer-size CPU stress).
    // measureTruePeak (buffer);

    // Envelope System (Micro + Macro, coupled)
    // - All control-domain attenuation is computed in dB domain.
    // - Micro: critically damped 2nd-order follower of the instantaneous attenuation target (no overshoot).
    // - Macro: bounded energy accumulator influences micro recovery behavior (no competing control paths).
    // - Stereo linking occurs after per-channel envelope generation.
    {
        const int numCh = juce::jmin (getTotalNumInputChannels(), buffer.getNumChannels());
        const int n     = buffer.getNumSamples();
        if (numCh <= 0 || n <= 0)
            return;

        // Softplus controls (smooth, monotonic, branch-free)
        constexpr double kEpsLin    = 1.0e-12; // avoids log(0)
        constexpr double kSoftK     = 32.0;
        constexpr double kMaxAttnDb = 120.0;

        


        // Time constants (seconds). Names avoid forbidden terminology.
        // "Micro" is ultra-fast; "Macro" is slower density behavior.
        constexpr double kMicroSecBase = 0.0080; // 8 ms nominal
        constexpr double kMacroSecBase = 0.1200; // 120 ms nominal

        // Coupling strength: macro energy influences micro recovery speed.
        constexpr double kCouple = 1.25;

        // Oversampled audio-path processing (no allocations in audio thread).
        // Fallback to native-rate if scratch buffer is not prepared for this block size / channel count.
        const bool canOsAudio =
            (activeOversampler != nullptr) &&
            (workBufferFloat.getNumChannels() >= numCh) &&
            (workBufferFloat.getNumSamples()  >= n);

        if (canOsAudio)
        {
            // CPU fast-path: if this block cannot exceed Ceiling after Drive AND envelope state is at rest,
            // skip oversampling + heavy inner loop, but advance smoothers deterministically.
            bool skipOsFastPath = false;
            {
                // Only skip if envelope state is already effectively at rest (avoids dropping residual GR).
                constexpr double kRestDb = 1.0e-3;  // ~0.001 dB
                constexpr double kRestEn = 1.0e-6;  // tiny macro energy

                const bool envAtRest =
                    (std::abs (microStage2DbState[0]) <= kRestDb) &&
                    (std::abs (microStage2DbState[1]) <= kRestDb) &&
                    (std::abs (macroEnergyState[0])   <= kRestEn) &&
                    (std::abs (macroEnergyState[1])   <= kRestEn);

                if (envAtRest)
                {
                    float peak = 0.0f;
                    for (int c = 0; c < numCh; ++c)
                    {
                        const float* p = buffer.getReadPointer (c);
                        for (int i = 0; i < n; ++i)
                        {
                            const float a = std::abs (p[i]);
                            if (a > peak) peak = a;
                        }
                    }

                    // Conservative overshoot test using target values (no per-sample smoothing work).
                    // If even the block peak cannot exceed ceiling after Drive, attenuation is guaranteed 0.
                    constexpr double kEpsLinFast = 1.0e-12;
                    const double tpDbPeak   = 20.0 * std::log10 ((double) peak + kEpsLinFast);
                    const double driveDbT   = (double) driveDbSmoothed.getTargetValue();
                    const double ceilingDbT = (double) ceilingDbSmoothed.getTargetValue();

                    // Small negative margin keeps us safely on the "no GR" side.
                    if (((tpDbPeak + driveDbT) - ceilingDbT) <= -0.05)
                        skipOsFastPath = true;
                }
            }

            skipOsFastPath = false;

            if (! skipOsFastPath)
            {

            // Copy float -> double scratch (native-rate, length n)
            for (int c = 0; c < numCh; ++c)
            {
                const float* src = buffer.getReadPointer (c);
                float* dst = workBufferFloat.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = src[i];
            }

            juce::dsp::AudioBlock<float> fullBlock (workBufferFloat);
            auto blockN = fullBlock.getSubBlock (0, (size_t) n);

            juce::ScopedNoDenormals innerNoDenormals;
            auto osBlock = activeOversampler->processSamplesUp (blockN);

            const int osCh = (int) osBlock.getNumChannels();
            const int osN  = (int) osBlock.getNumSamples();

            const int osFactor = juce::jmax (1, (int) activeOversampler->getOversamplingFactor());
            const double dtOS  = lastInvSampleRate / (double) osFactor;

            // Cache oversampled channel pointers (hot path, no allocations)
            constexpr int kOsChCacheMax = 8;
            std::array<float*, (size_t) kOsChCacheMax> osPtr {};
            const int osCached = juce::jmin (juce::jmin (numCh, osCh), kOsChCacheMax);
            for (int c = 0; c < osCached; ++c)
                osPtr[(size_t) c] = osBlock.getChannelPointer ((size_t) c);

            // Phase D: materialize a fixed pointer array for the sample helper (no allocation).
            std::array<float*, (size_t) kOsChCacheMax> osPtrArr {};
            const int numChEff = juce::jmin (juce::jmin (numCh, osCh), kOsChCacheMax);
            for (int c = 0; c < numChEff; ++c)
                osPtrArr[(size_t) c] = (c < osCached ? osPtr[(size_t) c] : osBlock.getChannelPointer ((size_t) c));

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb
            const int tpCh = juce::jmin (2, numChEff);

            


            


            // Advance smoothers at native rate (one step per native sample), reuse values across osFactor sub-samples.
            for (int iN = 0; iN < n; ++iN)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = juce::jlimit (0.0, 1.0, (double) adaptiveBias01Smoothed.getNextValue());
                const double link01    = juce::jlimit (0.0, 1.0, (double) stereoLink01Smoothed.getNextValue());

                for (int k = 0; k < osFactor; ++k)
                {
                    const int i = iN * osFactor + k;
                    if (i >= osN)
                        break;

                    for (int c = 0; c < tpCh; ++c)
                    {
                        const double a = std::abs ((double) osPtrArr[(size_t) c][i]);
                        if (std::isfinite (a))
                            inTpHold[(size_t) c] = juce::jmax (inTpHold[(size_t) c], a);
                    }

                    processOneSample (osPtrArr.data(), numChEff, i, dtOS, driveDb, ceilingDb, bias01, link01, grDbNegMin);

                    for (int c = 0; c < tpCh; ++c)
                    {
                        const double a = std::abs ((double) osPtrArr[(size_t) c][i]);
                        if (std::isfinite (a))
                            outTpHold[(size_t) c] = juce::jmax (outTpHold[(size_t) c], a);
                    }
                }
            }

            grDbForUI.store ((float) juce::jlimit (0.0, 120.0, -grDbNegMin), std::memory_order_relaxed);


            activeOversampler->processSamplesDown (blockN);

            // Copy double -> float output (native-rate)
            for (int c = 0; c < numCh; ++c)
            {
                const float* src = workBufferFloat.getReadPointer (c);
                float* dst = buffer.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = (float) src[i];
            }
            }
            else
            {
                // Deterministic advancement of smoothers (native-rate length n), with no audio-path work.
                driveDbSmoothed.skip (n);
                ceilingDbSmoothed.skip (n);
                adaptiveBias01Smoothed.skip (n);
                stereoLink01Smoothed.skip (n);

                grDbForUI.store (0.0f, std::memory_order_relaxed);
            }
        }
        else
        {
            // Native-rate fallback (prior behavior). No allocations. Deterministic.
            // Phase 11 note: input TP is sample-peak here unless/until true-peak is enabled for this path; do not add a new OS path just for input TP.
            constexpr int kChCacheMax = 8;
            std::array<float*, (size_t) kChCacheMax> chPtr {};
            const int chCached = juce::jmin (numCh, kChCacheMax);
            for (int c = 0; c < chCached; ++c)
                chPtr[(size_t) c] = buffer.getWritePointer (c);

            // Phase D: materialize a fixed pointer array for the sample helper (no allocation).
            std::array<float*, (size_t) kChCacheMax> chPtrArr {};
            const int numChEff = juce::jmin (numCh, kChCacheMax);
            for (int c = 0; c < numChEff; ++c)
                chPtrArr[(size_t) c] = (c < chCached ? chPtr[(size_t) c] : buffer.getWritePointer (c));

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb

            


            for (int i = 0; i < n; ++i)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = juce::jlimit (0.0, 1.0, (double) adaptiveBias01Smoothed.getNextValue());
                const double link01    = juce::jlimit (0.0, 1.0, (double) stereoLink01Smoothed.getNextValue());

                const int tpCh = juce::jmin (2, numChEff);
                for (int c = 0; c < tpCh; ++c)
                {
                    const double a = std::abs ((double) chPtrArr[(size_t) c][i]);
                    if (std::isfinite (a))
                        inTpHold[(size_t) c] = juce::jmax (inTpHold[(size_t) c], a);
                }

                processOneSample (chPtrArr.data(), numChEff, i, lastInvSampleRate, driveDb, ceilingDb, bias01, link01, grDbNegMin);
            }

            grDbForUI.store ((float) juce::jlimit (0.0, 120.0, -grDbNegMin), std::memory_order_relaxed);
        }
    }

    // Loudness update (Phase 11): from final native-rate output buffer (post-DSP).
    // Deterministic, bounded, no allocations.
    if (meterPublishSamples > 0)
    {
        const int numCh = juce::jmin (2, buffer.getNumChannels());
        const int n = buffer.getNumSamples();

        for (int i = 0; i < n; ++i)
        {
            double e = 0.0;
            if (numCh >= 2)
            {
                const double y0 = (double) buffer.getSample (0, i);
                const double y1 = (double) buffer.getSample (1, i);
                e = 0.5 * (y0 * y0 + y1 * y1);
            }
            else if (numCh == 1)
            {
                const double y0 = (double) buffer.getSample (0, i);
                e = (y0 * y0);
            }

            if (! std::isfinite (e) || e < 0.0) e = 0.0;
            e = juce::jlimit (0.0, 1.0e12, e);

            lufsCurChunkE += e;
            lufsCurChunkN += 1;

            lufsIntSumE += e;
            lufsIntN    += 1u;

            if (lufsCurChunkN >= meterPublishSamples)
            {
                const double oldE = lufsChunkE[(size_t) lufsChunkWrite];
                if (lufsChunkFilled >= (uint32_t) kLufsShortChunks)
                    lufsShortSumE -= oldE;
                else
                    lufsChunkFilled += 1u;

                lufsChunkE[(size_t) lufsChunkWrite] = lufsCurChunkE;
                lufsShortSumE += lufsCurChunkE;

                lufsChunkWrite = (lufsChunkWrite + 1u) % (uint32_t) kLufsShortChunks;

                lufsCurChunkE = 0.0;
                lufsCurChunkN = 0;
            }
        }
    }

    // Meter publish cadence (~50 Hz). Publish latest holds (bounded), then reset holds.
    // Audio thread: must remain allocation-free and lock-free.
    if (meterPublishSamples > 0)
    {
        meterCountdown -= buffer.getNumSamples();
        while (meterCountdown <= 0)
        {
            MeterSnapshot s{};

            constexpr double kEps = 1.0e-12;

            for (int c = 0; c < 2; ++c)
            {
                double x = inPeakHold[c];
                if (! std::isfinite (x) || x < 0.0) x = 0.0;
                x = juce::jlimit (0.0, 1.0e6, x);
                double db = 20.0 * std::log10 (x + kEps);
                s.inPeakDb[c] = juce::jlimit (-120.0, 60.0, db);

                x = outPeakHold[c];
                if (! std::isfinite (x) || x < 0.0) x = 0.0;
                x = juce::jlimit (0.0, 1.0e6, x);
                db = 20.0 * std::log10 (x + kEps);
                s.outPeakDb[c] = juce::jlimit (-120.0, 60.0, db);

                x = inTpHold[c];
                if (! std::isfinite (x) || x < 0.0) x = 0.0;
                x = juce::jlimit (0.0, 1.0e6, x);
                db = 20.0 * std::log10 (x + kEps);
                s.inTpDb[c] = juce::jlimit (-120.0, 60.0, db);

                x = outTpHold[c];
                if (! std::isfinite (x) || x < 0.0) x = 0.0;
                x = juce::jlimit (0.0, 1.0e6, x);
                db = 20.0 * std::log10 (x + kEps);
                s.outTpDb[c] = juce::jlimit (-120.0, 60.0, db);

                x = grHoldDb[c];
                if (! std::isfinite (x) || x < 0.0) x = 0.0;
                s.grDb[c] = juce::jlimit (0.0, 120.0, x);
            }

            // Crest factor (broadband): stereo peak minus stereo RMS.
            // Stereo peak: max(L,R). Stereo RMS: max-energy channel (max sumSq) -> RMS dB.
            {
                const double win = (double) juce::jmax (1, meterPublishSamples);

                const double inPeakStereoDb  = juce::jmax (s.inPeakDb[0],  s.inPeakDb[1]);
                const double outPeakStereoDb = juce::jmax (s.outPeakDb[0], s.outPeakDb[1]);

                double inSumSqSel = juce::jmax (inRmsSq[0], inRmsSq[1]);
                if (! std::isfinite (inSumSqSel) || inSumSqSel < 0.0) inSumSqSel = 0.0;
                inSumSqSel = juce::jlimit (0.0, 1.0e12, inSumSqSel);
                double inRmsStereoDb = 10.0 * std::log10 ((inSumSqSel / win) + kEps);
                if (! std::isfinite (inRmsStereoDb)) inRmsStereoDb = -120.0;
                inRmsStereoDb = juce::jlimit (-120.0, 60.0, inRmsStereoDb);

                double outSumSqSel = juce::jmax (outRmsSq[0], outRmsSq[1]);
                if (! std::isfinite (outSumSqSel) || outSumSqSel < 0.0) outSumSqSel = 0.0;
                outSumSqSel = juce::jlimit (0.0, 1.0e12, outSumSqSel);
                double outRmsStereoDb = 10.0 * std::log10 ((outSumSqSel / win) + kEps);
                if (! std::isfinite (outRmsStereoDb)) outRmsStereoDb = -120.0;
                outRmsStereoDb = juce::jlimit (-120.0, 60.0, outRmsStereoDb);

                double crest = inPeakStereoDb - inRmsStereoDb;
                if (! std::isfinite (crest)) crest = 0.0;
                s.crestPreDb = juce::jlimit (-60.0, 120.0, crest);

                crest = outPeakStereoDb - outRmsStereoDb;
                if (! std::isfinite (crest)) crest = 0.0;
                s.crestPostDb = juce::jlimit (-60.0, 120.0, crest);
            }

            // Loudness (Phase 11): unweighted energy, deterministic. Bounded for UI sanity.
            {
                constexpr double kEps = 1.0e-18;
                constexpr double kOffset = -0.691; // LUFS-style offset (unweighted here by constitution)

                const double shortE = lufsShortSumE + lufsCurChunkE;
                const double shortN = (double) (lufsChunkFilled) * (double) juce::jmax (1, meterPublishSamples) + (double) lufsCurChunkN;
                double msShort = (shortN > 0.0 ? (shortE / shortN) : 0.0);
                if (! std::isfinite (msShort) || msShort < 0.0) msShort = 0.0;
                msShort = juce::jlimit (0.0, 1.0e12, msShort);

                double lufsShort = kOffset + 10.0 * std::log10 (msShort + kEps);
                if (! std::isfinite (lufsShort)) lufsShort = -120.0;
                s.lufsShortDb = juce::jlimit (-120.0, 60.0, lufsShort);

                const double intN = (double) lufsIntN;
                double msInt = (intN > 0.0 ? (lufsIntSumE / intN) : 0.0);
                if (! std::isfinite (msInt) || msInt < 0.0) msInt = 0.0;
                msInt = juce::jlimit (0.0, 1.0e12, msInt);

                double lufsInt = kOffset + 10.0 * std::log10 (msInt + kEps);
                if (! std::isfinite (lufsInt)) lufsInt = -120.0;
                s.lufsIntDb = juce::jlimit (-120.0, 60.0, lufsInt);
            }

            publishMeters (s);

            for (int c = 0; c < 2; ++c)
            {
                inPeakHold[c]  = 0.0;
                outPeakHold[c] = 0.0;
                inRmsSq[c]     = 0.0;
                outRmsSq[c]    = 0.0;
                inTpHold[c]    = 0.0;
                outTpHold[c]   = 0.0;
                grHoldDb[c]    = 0.0;
            }

            meterCountdown += meterPublishSamples;
        }
    }

    // CPU overload behavior: if we exceed a conservative share of block duration, enable assist briefly.
    {
        const auto tEnd = juce::Time::getHighResolutionTicks();
        const double elapsedSec = juce::Time::highResolutionTicksToSeconds (tEnd - tBlockStart);
        const int n = buffer.getNumSamples();
        const double blockSec = (lastSampleRate > 0.0 ? (double) n / lastSampleRate : 0.0);

        // If we're close to the deadline, disable guardrails extras for a short period.
        if (blockSec > 0.0 && elapsedSec > 0.85 * blockSec)
            overloadAssistBlocks = juce::jmax (overloadAssistBlocks, 64);

        if (overloadAssistBlocks > 0)
            --overloadAssistBlocks;
    }

    // NaN/Inf containment (release): if we tripped bad math, force safe output and reset state.
    if (badMathThisBlock)
    {
        // Force safe output (prevents explosions/ceiling risk); reset internal state so next block is stable.
        buffer.clear();

        truePeakLin = 0.0;
        microStage1DbState = { 0.0, 0.0 };
        microStage2DbState = { 0.0, 0.0 };
        macroEnergyState   = { 0.0, 0.0 };
        crestRmsSqState    = { 0.0, 0.0 };
        eventDensityState  = { 0.0, 0.0 };
        guardLpState       = { 0.0, 0.0 };
        guardTotE          = { 0.0, 0.0 };
        guardHiE           = { 0.0, 0.0 };
        lastAppliedAttnDb  = { 0.0, 0.0 };

        grDbForUI.store (0.0f, std::memory_order_relaxed);
    }

    // Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::processBlockBypassed (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // True bypass: do not touch transport/smoothers/adaptive state.
    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // Session reload must restore identical internal state.
    auto root = apvts->copyState().createXml();
    if (root == nullptr)
        root = std::make_unique<juce::XmlElement> ("PARAMS");

    auto* internal = root->createNewChildElement ("internal_state");
    internal->setAttribute ("transportKnown", (int) transportKnown);
    internal->setAttribute ("lastTransportPlaying", (int) lastTransportPlaying);

    copyXmlToBinary (*root, destData);
}

void CompassMasteringLimiterAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (xml == nullptr)
        return;

    if (xml->hasTagName (apvts->state.getType()))
        apvts->replaceState (juce::ValueTree::fromXml (*xml));
    else
        apvts->replaceState (juce::ValueTree::fromXml (*xml));

    if (auto* internal = xml->getChildByName ("internal_state"))
    {
        transportKnown = (internal->getIntAttribute ("transportKnown", 0) != 0);
        lastTransportPlaying = (internal->getIntAttribute ("lastTransportPlaying", 0) != 0);
    }
    else
    {
        transportKnown = false;
        lastTransportPlaying = false;
    }

    // Constitution: recall/reload must restore identical internal state.
    // Do not hard-reset adaptive/envelope/guard state here.
    // Sync smoothed parameters to loaded values (no ramp) to prevent discontinuities.
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}


void CompassMasteringLimiterAudioProcessor::prepareOversampling (int channels, int maxBlock)
{
    const int ch = juce::jmax (1, channels);
    const int mb = juce::jmax (1, maxBlock);

    // Prebuild 2x/4x/8x with FIR equiripple halfband filters (linear-phase).
    for (int i = 0; i < kOsCount; ++i)
    {
        const int stages = i + 1; // 1->2x, 2->4x, 3->8x
        oversamplers[(size_t) i] = std::make_unique<juce::dsp::Oversampling<float>>(
            ch,
            stages,
            juce::dsp::Oversampling<float>::filterHalfBandFIREquiripple,
            true
        );

        oversamplers[(size_t) i]->initProcessing ((size_t) mb);
        oversamplers[(size_t) i]->reset();

        oversamplerLatencySamples[(size_t) i] = oversamplers[(size_t) i]->getLatencyInSamples();
    }

    // Scratch buffer for input conversion (double precision).
    workBufferFloat.setSize (ch, mb, false, false, true);

    // Default active oversampler is 2x until boundary latch selects otherwise.
    activeOversampler = oversamplers[0].get();
    setLatencySamples (oversamplerLatencySamples[0]);
}

void CompassMasteringLimiterAudioProcessor::selectOversamplingAtBoundary (int osMinIndex) noexcept
{
    const int idx = juce::jlimit (0, kOsCount - 1, osMinIndex);
    latchedOsMinIndex = idx;

    auto* os = oversamplers[(size_t) idx].get();
    if (os != nullptr)
    {
        activeOversampler = os;
        setLatencySamples (oversamplerLatencySamples[(size_t) idx]);

        // Deterministic, transport-safe boundary behavior:
        // reset oversampler state only when latching selection (not per block).
        activeOversampler->reset();
    }
}

void CompassMasteringLimiterAudioProcessor::measureTruePeak (const juce::AudioBuffer<float>& buffer) noexcept
{
    truePeakLin = 0.0;

    const int ch = juce::jmin (2, buffer.getNumChannels());
    const int n  = buffer.getNumSamples();
    if (ch <= 0 || n <= 0)
        return;

    // If input is effectively silent, reset FIR history to prevent denormal accumulation
    // in FIR filter history (common crackle source under heavy attenuation / silence).
    constexpr float kSilenceLin = 1.0e-8f;

    float inPeak = 0.0f;
    for (int c = 0; c < ch; ++c)
    {
        const float* src = buffer.getReadPointer (c);
        for (int i = 0; i < n; ++i)
        {
            const float a = std::abs (src[i]);
            if (a > inPeak) inPeak = a;
        }
    }

    if (inPeak < kSilenceLin)
    {
        truePeakLin = 0.0;

        // Phase 1.2 Step 5 — silence soak (decay-only, no FIR work):
        // Preserve detector-owned sustained energy as a deterministic decay across this silent block,
        // while still clearing FIR/transient history to prevent denormal accumulation.
        const double dtDet = lastInvSampleRate / (double) kTpOSFactor;
        const double aS    = onePoleAlpha (kTpSustainedTauSec, dtDet);
        const int    nDet  = n * kTpOSFactor;
        const double aBlk  = std::pow (aS, (double) nDet);

        std::array<double, 2> eKeep { 0.0, 0.0 };
        for (int c = 0; c < 2; ++c)
        {
            double e = tpSustainedPowEma[(size_t) c];
            if (! std::isfinite (e) || e < 0.0) e = 0.0;
            eKeep[(size_t) c] = e * aBlk;
        }

        resetTruePeakDetector();

        for (int c = 0; c < 2; ++c)
            tpSustainedPowEma[(size_t) c] = eKeep[(size_t) c];

        return;
    }

    double tpCh[2] = { 0.0, 0.0 };

    // Phase 1.2 — Sustained energy accumulator (detector domain):
    // Update cadence: per reconstructed sample (4x).
    const double dtDet = lastInvSampleRate / (double) kTpOSFactor;
    const double aS    = onePoleAlpha (kTpSustainedTauSec, dtDet);

    // Polyphase FIR reconstruction (4x):
    // y[n*L + p] = sum_k h[p + L*k] * x[n - k]
    for (int c = 0; c < ch; ++c)
    {
        int pos = tpHistPos[(size_t) c];
        const float* src = buffer.getReadPointer (c);

        double localPeak = 0.0;

        for (int i = 0; i < n; ++i)
        {
            const double x = (double) src[i];

            tpHist[(size_t) c][(size_t) pos] = x;
            pos = (pos + 1) % kTpTaps;

            const int newest = pos - 1;

            for (int p = 0; p < kTpOSFactor; ++p)
            {
                double acc = 0.0;
                int k = 0;

                for (int t = p; t < kTpTaps; t += kTpOSFactor)
                {
                    int idx = newest - k;
                    if (idx < 0) idx += kTpTaps;

                    acc += kTpFIR[(size_t) t] * tpHist[(size_t) c][(size_t) idx];
                    ++k;
                }

                // Sustained energy (broadband power EMA), deterministic + stable:
                // finite containment only; no hot-loop clamps.
                const double accSafe = (std::isfinite (acc) ? acc : 0.0);
                const double pwr = accSafe * accSafe;
                tpSustainedPowEma[(size_t) c] = aS * tpSustainedPowEma[(size_t) c] + (1.0 - aS) * pwr;

                const double a = std::abs (accSafe);
                if (a > localPeak)
                    localPeak = a;
            }
        }

        tpHistPos[(size_t) c] = pos;

        tpCh[c] = localPeak;

        // Phase 1.2 Step 3 — transient event derivative (detector domain):
        // First-order temporal derivative of peak magnitude (rising edge only).
        tpDerivLin[(size_t) c] = tpCh[c] - prevTpChLin[(size_t) c];
        if (tpDerivLin[(size_t) c] < 0.0)
            tpDerivLin[(size_t) c] = 0.0;
        prevTpChLin[(size_t) c] = tpCh[c];

        // Meter accumulator storage (input true peak hold, linear).
        if (tpCh[c] > inTpHold[c])
            inTpHold[c] = tpCh[c];
    }

    // Preserve existing scalar: max across channels.
    truePeakLin = tpCh[0];
    if (tpCh[1] > truePeakLin)
        truePeakLin = tpCh[1];

    // Diagnostic-only safety: if near-silence, reset FIR history to rule out denormal accumulation.
    if (truePeakLin < 1.0e-5)
        resetTruePeakDetector();
}

juce::AudioProcessorEditor* CompassMasteringLimiterAudioProcessor::createEditor()
{
    return new CompassMasteringLimiterAudioProcessorEditor (*this);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CompassMasteringLimiterAudioProcessor();
}

===== FILE: Source/Plugin/PluginProcessor.h =====

#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_dsp/juce_dsp.h>
#include <array>
#include <memory>
#include <atomic>
#include <cstdint>

class CompassMasteringLimiterAudioProcessor final : public juce::AudioProcessor
{
public:
    using APVTS = juce::AudioProcessorValueTreeState;

    CompassMasteringLimiterAudioProcessor();
    ~CompassMasteringLimiterAudioProcessor() override = default;

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void processBlockBypassed (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    const juce::String getName() const override { return "Compass Mastering Limiter"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}

    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    APVTS& getAPVTS() noexcept { return *apvts; }
    const APVTS& getAPVTS() const noexcept { return *apvts; }

    float getCurrentGRDb() const noexcept { return grDbForUI.load(std::memory_order_relaxed); }

    bool getCurrentTruePeakDbTP (float& inDbTP, float& outDbTP) const noexcept
    {
        MeterSnapshot s{};
        if (! readMeters (s))
            return false;

        const double inStereo  = juce::jmax (s.inTpDb[0],  s.inTpDb[1]);
        const double outStereo = juce::jmax (s.outTpDb[0], s.outTpDb[1]);

        const double inClamped  = juce::jlimit (-120.0, 60.0, inStereo);
        const double outClamped = juce::jlimit (-120.0, 60.0, outStereo);

        inDbTP  = (float) inClamped;
        outDbTP = (float) outClamped;
        return true;
    }

    bool getCurrentLufsDb (float& lufsS, float& lufsI) const noexcept
    {
        MeterSnapshot s{};
        if (! readMeters (s))
            return false;

        const double sClamped = juce::jlimit (-120.0, 60.0, s.lufsShortDb);
        const double iClamped = juce::jlimit (-120.0, 60.0, s.lufsIntDb);

        lufsS = (float) sClamped;
        lufsI = (float) iClamped;
        return true;
    }

    bool getCurrentPeakDbFS (float& inDbFS, float& outDbFS) const noexcept
    {
        MeterSnapshot s{};
        if (! readMeters (s))
            return false;

        const double inStereo  = juce::jmax (s.inPeakDb[0],  s.inPeakDb[1]);
        const double outStereo = juce::jmax (s.outPeakDb[0], s.outPeakDb[1]);

        const double inClamped  = juce::jlimit (-120.0, 60.0, inStereo);
        const double outClamped = juce::jlimit (-120.0, 60.0, outStereo);

        inDbFS  = (float) inClamped;
        outDbFS = (float) outClamped;
        return true;
    }

    float getCurrentCeilingDbTP() const noexcept
    {
        const float v = apvts->getRawParameterValue ("ceiling")->load();
        return (float) juce::jlimit (-120.0f, 60.0f, v);
    }

private:
    static APVTS::ParameterLayout createParameterLayout();

    // Meter snapshot (POD, numeric-only). UI may consume via future plumbing.
    // Step 1.1: declare the data structure only (no instances, no publication mechanism yet).
    struct MeterSnapshot final
    {
        double   inPeakDb[2]   { 0.0, 0.0 };
        double   outPeakDb[2]  { 0.0, 0.0 };

        double   inTpDb[2]     { 0.0, 0.0 };
        double   outTpDb[2]    { 0.0, 0.0 };

        double   grDb[2]       { 0.0, 0.0 }; // attenuation magnitude in dB (0..+)
        double   lufsShortDb   = 0.0;
        double   lufsIntDb     = 0.0;

        double   crestPreDb    = 0.0;
        double   crestPostDb   = 0.0;

        uint64_t frameCounter  = 0; // monotonic debug-only counter
    };

    // Meter publication primitive (SPSC ring, lock-free; declarations only in this step).
    // Producer: audio thread. Consumer: UI thread.
    //
    // Publication rules:
    // - Audio thread writes at a fixed cadence (e.g., every 256 or 512 samples).
    // - If ring is full, new writes overwrite the oldest unread snapshot (consumer may miss frames).
    // - UI reads opportunistically; missed frames are acceptable.
    // - Snapshot is immutable once published (writer writes slot fully, then advances write index).
    //
    // Indices are modulo kMeterRingCapacity.
    static constexpr uint32_t kMeterRingCapacity = 128; // fixed, no allocations
    std::array<MeterSnapshot, (size_t) kMeterRingCapacity> meterRing {};

    // writeIndex: next slot the producer will publish.
    // readIndex:  next slot the consumer will read (advanced by consumer; may be forced forward on overwrite).
    // meterSeq:   publication signal (incremented by producer AFTER a snapshot is fully written and published).
    std::atomic<uint32_t> meterWriteIndex { 0u };
    mutable std::atomic<uint32_t> meterReadIndex  { 0u };
    std::atomic<uint32_t> meterSeq        { 0u }; // wraparound OK

    // Consumer-side tracking for readMeters(): updated only by UI thread.
    // Atomic is used defensively; keep usage contained to metering plumbing only.
    mutable std::atomic<uint32_t> meterLastReadSeq { 0u };

    void publishMeters (const MeterSnapshot& s) noexcept;
    bool readMeters (MeterSnapshot& out) const noexcept;

    // Meter accumulators (double precision) — Step 3.1 (storage only; no meter math/publishing yet)
    double inPeakHold[2]  = { 0.0, 0.0 };
    double outPeakHold[2] = { 0.0, 0.0 };
    double inRmsSq[2]     = { 0.0, 0.0 };
    double outRmsSq[2]    = { 0.0, 0.0 };
    double inTpHold[2]    = { 0.0, 0.0 };
    double outTpHold[2]   = { 0.0, 0.0 };
    double grHoldDb[2]    = { 0.0, 0.0 }; // attenuation magnitude in dB (0..+)

    // Meter publish timing (members) — configured/used in later steps
    int    meterPublishSamples = 0;
    int    meterCountdown      = 0;
    double meterDt             = 0.0;

    // Loudness state (Phase 11): deterministic, bounded, allocation-free.
    // Short-term is a fixed 3.0 s window implemented as 150 chunks at the meter cadence (~50 Hz).
    // Integrated is a running mean-square accumulator.
    static constexpr int kLufsHz          = 50;
    static constexpr int kLufsShortSec    = 3;
    static constexpr int kLufsShortChunks = kLufsHz * kLufsShortSec; // 150 (fixed, no allocations)

    std::array<double, (size_t) kLufsShortChunks> lufsChunkE {};
    uint32_t lufsChunkWrite  = 0u;
    uint32_t lufsChunkFilled = 0u;
    double   lufsShortSumE   = 0.0;

    double   lufsCurChunkE   = 0.0;
    int      lufsCurChunkN   = 0;

    double   lufsIntSumE     = 0.0;
    uint64_t lufsIntN        = 0u;

    // Gate-3 deterministic state model:
    void reset (double sampleRate, int maxBlock, int channels) noexcept;

    // Oversampling + True Peak (Gate-4):
    // - FIR polyphase only (linear-phase reconstruction)
    // - Oversampling is prebuilt in prepareToPlay (no allocations in audio thread)
    // - Active oversampling selection changes only on transport stop/start edge
    void prepareOversampling (int channels, int maxBlock);
    void selectOversamplingAtBoundary (int osMinIndex) noexcept;
    void measureTruePeak (const juce::AudioBuffer<float>& buffer) noexcept;

    // Phase D: promoted helpers (no allocations, no virtual dispatch)
    static double onePoleAlpha (double tauSec, double dtSec) noexcept;
    void processOneSample (float* const* chPtr,
                          int numCh,
                          int i,
                          double dt,
                          double driveDb,
                          double ceilingDb,
                          double bias01,
                          double link01,
                          double& grDbNegMin) noexcept;

    // Gate-2 smoothing policy (declared now; configured in prepareToPlay/reset):
    // - Drive/Ceiling: sample-accurate linear ramps (SmoothedValue)
    // - Stereo Link / Adaptive Bias: smoothed (SmoothedValue)
    // - Oversampling Min: discrete choice (no smoothing)
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> driveDbSmoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> ceilingDbSmoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> adaptiveBias01Smoothed;
    juce::SmoothedValue<float, juce::ValueSmoothingTypes::Linear> stereoLink01Smoothed;

    // Deterministic lifecycle context (captured in prepareToPlay/reset):
    double lastSampleRate = 0.0;
    double lastInvSampleRate = 0.0; // cached 1 / lastSampleRate (SR-derived coeff scalar)
    double effectiveControlInvDt = 0.0; // 1.0 / nativeSR
    double effectiveAudioInvDt   = 0.0; // 1.0 / (nativeSR * OSFactor); OSFactor=1.0 for now
    int lastMaxBlock = 0;
    int lastChannels = 0;

    // Transport edge detection (stop/start triggers reset semantics):
    bool transportKnown = false;
    bool lastTransportPlaying = false;

    // Oversampling (prebuilt instances; selected at transport-safe boundary only)
    static constexpr int kOsCount = 3; // 2x / 4x / 8x
    std::array<std::unique_ptr<juce::dsp::Oversampling<float>>, kOsCount> oversamplers;
    juce::dsp::Oversampling<float>* activeOversampler = nullptr;
    std::array<int, kOsCount> oversamplerLatencySamples { 0, 0, 0 };
    int latchedOsMinIndex = 0; // 0=2x, 1=4x, 2=8x (latched only at boundary)

    // Control-domain true peak (linear)
    double truePeakLin = 0.0;

    // Phase 1.2 — True-Peak Detector Path (Reference)
    // Polyphase FIR oversampled reconstruction (linear-phase, deterministic coefficients).
    // Implemented as 4x interpolation; coefficients are symmetric (linear-phase) and normalized so sum(h) == 4.0.
    static constexpr int kTpOSFactor = 4;
    static constexpr int kTpTaps     = 32; // must be even and divisible by kTpOSFactor

    static constexpr std::array<double, kTpTaps> kTpFIR {
        -0.000000000000000000e+00,
        -8.291365655703771638e-04,
        -3.525756966746731828e-03,
        -3.488316484777266926e-03,
         6.579729475753049242e-03,
         2.634752184268256830e-02,
         4.035166818965605501e-02,
         2.428673766138198312e-02,
        -3.407969929110992585e-02,
        -1.130051644440947245e-01,
        -1.538132119698306655e-01,
        -8.715260485310091787e-02,
         1.222467629501392816e-01,
         4.403366958529203457e-01,
         7.651370491704410082e-01,
         9.706077254322565961e-01,
         9.706077254322565961e-01,
         7.651370491704410082e-01,
         4.403366958529203457e-01,
         1.222467629501392955e-01,
        -8.715260485310093175e-02,
        -1.538132119698306377e-01,
        -1.130051644440948078e-01,
        -3.407969929110995361e-02,
         2.428673766138198312e-02,
         4.035166818965605501e-02,
         2.634752184268256830e-02,
         6.579729475753050977e-03,
        -3.488316484777266926e-03,
        -3.525756966746731828e-03,
        -8.291365655703861626e-04,
        -0.000000000000000000e+00
    };

    // Per-channel FIR history (preallocated; 2-channel accumulator contract).
    std::array<std::array<double, kTpTaps>, 2> tpHist{};
    std::array<int, 2> tpHistPos{};

    // Detector-domain transient feature:
    // First-order temporal derivative of peak magnitude (linear), per channel, per block.
    std::array<double, 2> prevTpChLin { 0.0, 0.0 };
    std::array<double, 2> tpDerivLin  { 0.0, 0.0 };

    // Phase 1.2 — Sustained energy accumulator (detector domain):
    // Broadband power EMA of reconstructed samples (double), per channel.
    // Decay law is locked: a = exp(-dt/tau) via onePoleAlpha(tau, dt).
    static constexpr double kTpSustainedTauSec = 0.040;
    std::array<double, 2> tpSustainedPowEma { 0.0, 0.0 };

    void resetTruePeakDetector() noexcept
    {
        for (int c = 0; c < 2; ++c)
        {
            tpHist[(size_t) c].fill (0.0);
            tpHistPos[(size_t) c] = 0;

            prevTpChLin[(size_t) c] = 0.0;
            tpDerivLin[(size_t) c]  = 0.0;
            tpSustainedPowEma[(size_t) c] = 0.0;
        }
    }

    // UI meter readout (GR in dB, negative: 0..-60). Published once per block (atomic, lock-free).
    std::atomic<float> grDbForUI { 0.0f };


    // Output scalar continuity (tiny, deterministic) — prevents micro-steps reaching the output
    std::array<float, 2> lastOutScalar { 1.0f, 1.0f };
    // Guards + Safety Rails (Gate-10):
    // - Hard bounds: attenuation depth already clamped via kMaxAttnDb in processBlock
    // - Slew limiting: prevents extreme step changes from bad automation or math glitches
    std::array<double, 2> lastAppliedAttnDb { 0.0, 0.0 };

    // Tiny GR floor + hysteresis memory (per-channel) to prevent threshold chatter (observational behavior unchanged)
    std::array<double, 2> lastAttnTargetDb { 0.0, 0.0 };

    // CPU overload behavior: temporarily disable non-essential measurement extras (never changes user settings)
    int overloadAssistBlocks = 0;

    // NaN/Inf containment latch (release): if tripped, block output is forced safe and internal state resets
    bool badMathThisBlock = false;

    // Envelope system (Micro + Macro, coupled)
    // Micro: critically damped 2nd-order model (no overshoot; ultra-fast capture; no ringing)
    // Discrete-time implementation: two cascaded one-pole followers (stable for any dt; no stiffness).
    // Macro: energy accumulation + exponential decay (bounded; monotonic)
    // Coupling: macro state influences micro recovery behavior (no competing control paths)
    std::array<double, 2> microStage1DbState { 0.0, 0.0 };
    std::array<double, 2> microStage2DbState { 0.0, 0.0 };
    std::array<double, 2> macroEnergyState   { 0.0, 0.0 };

    // Gate: Adaptive Release inputs (deterministic, bounded, continuous)
    // - Crest factor proxy: short RMS energy accumulator (per-channel)
    // - Event density: continuous "event presence" accumulator (per-channel)
    std::array<double, 2> crestRmsSqState    { 0.0, 0.0 };
    std::array<double, 2> eventDensityState  { 0.0, 0.0 };

    // Spectral Guardrails (measurement-only; broadband application)
    // Parallel measurement path:
    // - frequency-selective measurement allowed
    // - must not influence detector/envelope timing/shape
    // - may only add subtle broadband GR under heavy limiting
    std::array<double, 2> guardLpState { 0.0, 0.0 }; // one-pole LP state for split
    std::array<double, 2> guardTotE   { 0.0, 0.0 }; // total energy EMA
    std::array<double, 2> guardHiE    { 0.0, 0.0 }; // high-band energy EMA

    // Scratch buffer for oversampled measurement (double precision)
    juce::AudioBuffer<float> workBufferFloat;

    std::unique_ptr<APVTS> apvts;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CompassMasteringLimiterAudioProcessor)
};
