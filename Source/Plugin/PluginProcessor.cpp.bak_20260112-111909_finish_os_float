#include "PluginProcessor.h"
#include "PluginEditor.h"

CompassMasteringLimiterAudioProcessor::CompassMasteringLimiterAudioProcessor()
: juce::AudioProcessor (BusesProperties()
#if ! JucePlugin_IsMidiEffect
 #if ! JucePlugin_IsSynth
    .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
 #endif
    .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
#endif
)
{
    apvts = std::make_unique<APVTS>(*this, nullptr, "PARAMS", createParameterLayout());
}

CompassMasteringLimiterAudioProcessor::APVTS::ParameterLayout
CompassMasteringLimiterAudioProcessor::createParameterLayout()
{
    APVTS::ParameterLayout layout;

    // IDs are constitution-locked (no aliases, no hidden controls)
    // Value ranges are defined exactly per Gate-2 spec.
    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "drive", 1 },
        "Drive",
        juce::NormalisableRange<float> { 0.0f, 20.0f, 0.01f },
        0.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dB"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "ceiling", 1 },
        "Ceiling",
        juce::NormalisableRange<float> { -6.0f, 0.0f, 0.01f },
        -0.3f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dBTP"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "adaptive_bias", 1 },
        "Adaptive Bias",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        0.5f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int)
        {
            // Label-only display (constitution): continuous scalar, descriptive labels only.
            // Mapping for display text only:
            // <= 1/3 -> Transparent, >= 2/3 -> Aggressive, else -> Balanced
            if (v <= (1.0f / 3.0f)) return juce::String ("Transparent");
            if (v >= (2.0f / 3.0f)) return juce::String ("Aggressive");
            return juce::String ("Balanced");
        },
        [] (const juce::String& s)
        {
            if (s.equalsIgnoreCase ("Transparent")) return 0.0f;
            if (s.equalsIgnoreCase ("Balanced"))    return 0.5f;
            if (s.equalsIgnoreCase ("Aggressive"))  return 1.0f;
            return s.getFloatValue();
        }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "stereo_link", 1 },
        "Stereo Link",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v * 100.0f, 1) + " %"; },
        [] (const juce::String& s) { return s.getFloatValue() / 100.0f; }
    ));

    layout.add (std::make_unique<juce::AudioParameterChoice>(
        juce::ParameterID { "oversampling_min", 1 },
        "Oversampling Min",
        juce::StringArray { "2x", "4x", "8x" },
        0
    ));

    return layout;
}

void CompassMasteringLimiterAudioProcessor::reset (double sampleRate, int maxBlock, int channels) noexcept
{
    lastSampleRate = (sampleRate > 0.0 ? sampleRate : 44100.0);
    lastInvSampleRate = 1.0 / juce::jmax (1.0, lastSampleRate);
    effectiveControlInvDt = lastInvSampleRate;
    effectiveAudioInvDt   = lastInvSampleRate; // OSFactor=1.0 until oversampled audio-path processing is introduced
    lastMaxBlock   = (maxBlock > 0 ? maxBlock : 0);
    lastChannels   = (channels > 0 ? channels : 0);

    // Deterministic reset of adaptive/envelope/guard state:
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.reset (lastSampleRate, 0.020);        // 20 ms
    ceilingDbSmoothed.reset (lastSampleRate, 0.020);      // 20 ms
    adaptiveBias01Smoothed.reset (lastSampleRate, 0.050); // 50 ms
    stereoLink01Smoothed.reset (lastSampleRate, 0.050);   // 50 ms

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);

    // Envelope state reset (deterministic; bounded)
    microStage1DbState = { 0.0, 0.0 };
    microStage2DbState = { 0.0, 0.0 };
    macroEnergyState   = { 0.0, 0.0 };
}

void CompassMasteringLimiterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
    reset (sampleRate, samplesPerBlock, ch);

    // Prebuild oversampling instances (no allocations in audio thread).
    prepareOversampling (ch, samplesPerBlock);

    // Latch initial oversampling selection (treated as transport-safe init).
    const int osMinIndex = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    selectOversamplingAtBoundary (osMinIndex);

    // Transport becomes unknown on prepare (hosts differ); edge detection begins on first block.
    transportKnown = false;
    lastTransportPlaying = false;
}

void CompassMasteringLimiterAudioProcessor::releaseResources()
{
}

bool CompassMasteringLimiterAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (! out.isDisabled());
}

void CompassMasteringLimiterAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals denormGuard;

    // Gate-3 deterministic transport semantics:
    // transport stop/start resets adaptive/envelope/guard states and is the only safe boundary for oversampling selection.
    if (auto* ph = getPlayHead())
    {
        juce::AudioPlayHead::CurrentPositionInfo pos;
        if (ph->getCurrentPosition (pos))
        {
            const bool playingNow = pos.isPlaying;
            if (! transportKnown)
            {
                transportKnown = true;
                lastTransportPlaying = playingNow;
            }
            else if (playingNow != lastTransportPlaying)
            {
                lastTransportPlaying = playingNow;

                const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
                reset (lastSampleRate, lastMaxBlock, ch);

                // Transport-safe boundary: latch oversampling selection (no allocations here).
                const int osMinIndexBoundary = (int) apvts->getRawParameterValue ("oversampling_min")->load();
                selectOversamplingAtBoundary (osMinIndexBoundary);
            }
        }
    }

    // Gate-2 rule: read params once per block into locals (atomics -> locals).
    const float driveDbTarget   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDbTarget = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01Target    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01Target    = apvts->getRawParameterValue ("stereo_link")->load();
    const int   osMinIndex      = (int) apvts->getRawParameterValue ("oversampling_min")->load();
    juce::ignoreUnused (osMinIndex);

    driveDbSmoothed.setTargetValue (driveDbTarget);
    ceilingDbSmoothed.setTargetValue (ceilingDbTarget);
    adaptiveBias01Smoothed.setTargetValue (bias01Target);
    stereoLink01Smoothed.setTargetValue (link01Target);

    // Control-domain true peak measurement disabled in Phase0 (buffer-size CPU stress).
    // measureTruePeak (buffer);

    // Envelope System (Micro + Macro, coupled)
    // - All control-domain attenuation is computed in dB domain.
    // - Micro: critically damped 2nd-order follower of the instantaneous attenuation target (no overshoot).
    // - Macro: bounded energy accumulator influences micro recovery behavior (no competing control paths).
    // - Stereo linking occurs after per-channel envelope generation.
    {
        const int numCh = juce::jmin (getTotalNumInputChannels(), buffer.getNumChannels());
        const int n     = buffer.getNumSamples();
        if (numCh <= 0 || n <= 0)
            return;

        // Softplus controls (smooth, monotonic, branch-free)
        constexpr double kEpsLin    = 1.0e-12; // avoids log(0)
        constexpr double kSoftK     = 32.0;
        constexpr double kMaxAttnDb = 120.0;

        // Time constants (seconds). Names avoid forbidden terminology.
        // "Micro" is ultra-fast; "Macro" is slower density behavior.
        constexpr double kMicroSecBase = 0.0080; // 8 ms nominal
        constexpr double kMacroSecBase = 0.1200; // 120 ms nominal

        // Coupling strength: macro energy influences micro recovery speed.
        constexpr double kCouple = 1.25;

        // Oversampled audio-path processing (no allocations in audio thread).
        // Fallback to native-rate if scratch buffer is not prepared for this block size / channel count.
        const bool canOsAudio =
            (activeOversampler != nullptr) &&
            (workBufferDouble.getNumChannels() >= numCh) &&
            (workBufferDouble.getNumSamples()  >= n);

        if (canOsAudio)
        {
            // CPU fast-path: if this block cannot exceed Ceiling after Drive AND envelope state is at rest,
            // skip oversampling + heavy inner loop, but advance smoothers deterministically.
            bool skipOsFastPath = false;
            {
                // Only skip if envelope state is already effectively at rest (avoids dropping residual GR).
                constexpr double kRestDb = 1.0e-3;  // ~0.001 dB
                constexpr double kRestEn = 1.0e-6;  // tiny macro energy

                const bool envAtRest =
                    (std::abs (microStage2DbState[0]) <= kRestDb) &&
                    (std::abs (microStage2DbState[1]) <= kRestDb) &&
                    (std::abs (macroEnergyState[0])   <= kRestEn) &&
                    (std::abs (macroEnergyState[1])   <= kRestEn);

                if (envAtRest)
                {
                    float peak = 0.0f;
                    for (int c = 0; c < numCh; ++c)
                    {
                        const float* p = buffer.getReadPointer (c);
                        for (int i = 0; i < n; ++i)
                        {
                            const float a = std::abs (p[i]);
                            if (a > peak) peak = a;
                        }
                    }

                    // Conservative overshoot test using target values (no per-sample smoothing work).
                    // If even the block peak cannot exceed ceiling after Drive, attenuation is guaranteed 0.
                    constexpr double kEpsLinFast = 1.0e-12;
                    const double tpDbPeak   = 20.0 * std::log10 ((double) peak + kEpsLinFast);
                    const double driveDbT   = (double) driveDbSmoothed.getTargetValue();
                    const double ceilingDbT = (double) ceilingDbSmoothed.getTargetValue();

                    // Small negative margin keeps us safely on the "no GR" side.
                    if (((tpDbPeak + driveDbT) - ceilingDbT) <= -0.05)
                        skipOsFastPath = true;
                }
            }

            if (! skipOsFastPath)
            {

            // Copy float -> double scratch (native-rate, length n)
            for (int c = 0; c < numCh; ++c)
            {
                const float* src = buffer.getReadPointer (c);
                double* dst = workBufferDouble.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = (double) src[i];
            }

            juce::dsp::AudioBlock<double> fullBlock (workBufferDouble);
            auto blockN = fullBlock.getSubBlock (0, (size_t) n);

            juce::ScopedNoDenormals innerNoDenormals;
            auto osBlock = activeOversampler->processSamplesUp (blockN);

            const int osCh = (int) osBlock.getNumChannels();
            const int osN  = (int) osBlock.getNumSamples();

            const int osFactor = juce::jmax (1, (int) activeOversampler->getOversamplingFactor());
            const double dtOS  = lastInvSampleRate / (double) osFactor;

            // Cache oversampled channel pointers (hot path, no allocations)
            constexpr int kOsChCacheMax = 8;
            std::array<double*, (size_t) kOsChCacheMax> osPtr {};
            const int osCached = juce::jmin (juce::jmin (numCh, osCh), kOsChCacheMax);
            for (int c = 0; c < osCached; ++c)
                osPtr[(size_t) c] = osBlock.getChannelPointer ((size_t) c);

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb

            // Advance smoothers at native rate (one step per native sample), reuse values across osFactor sub-samples.
            for (int iN = 0; iN < n; ++iN)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = (double) adaptiveBias01Smoothed.getNextValue();
                const double link01    = (double) stereoLink01Smoothed.getNextValue();

                for (int k = 0; k < osFactor; ++k)
                {
                    const int i = iN * osFactor + k;
                    if (i >= osN)
                        break;

                    // Per-channel: compute attenuation target, then advance micro+macro.
                    std::array<double, 2> attnDbCh { 0.0, 0.0 };

                    const int chProc = juce::jmin (2, numCh);
                    for (int c = 0; c < chProc; ++c)
                    {
                        const double s = (c < osCached ? osPtr[(size_t) c][i] : osBlock.getChannelPointer ((size_t) c)[i]);
                        const double tpDb = 20.0 * std::log10 (std::abs (s) + kEpsLin);

                        // dB "over ceiling" after Drive (control-domain)
                        const double x = (tpDb + driveDb) - ceilingDb;

                        // Softplus(x) / kSoftK  (stable, smooth max(0,x))
                        const double z = kSoftK * x;
                        const double softplus = z + std::log1p (std::exp (-std::abs (z)));
                        double attnTargetDb = softplus / kSoftK;
                        attnTargetDb = juce::jlimit (0.0, kMaxAttnDb, attnTargetDb);

                        // Macro energy (bounded, monotonic): integrate required attenuation magnitude (linearized)
                        // energyInput = 0 when attnTargetDb == 0
                        const double energyInput = juce::jmax (0.0, std::pow (10.0, attnTargetDb / 20.0) - 1.0);

                        // Macro time scaling via Adaptive Bias (continuous scalar; no branching)
                        const double macroSec = kMacroSecBase * (1.20 - 0.40 * bias01); // [~0.8x .. ~1.2x] nominal
                        const double aM = std::exp (-(dtOS) / juce::jmax (1.0e-6, macroSec));
                        macroEnergyState[(size_t) c] = aM * macroEnergyState[(size_t) c] + (1.0 - aM) * energyInput;

                        // Bound macro to avoid unbounded growth; mapping to [0,1) via energy/(1+energy)
                        const double macro01 = macroEnergyState[(size_t) c] / (1.0 + macroEnergyState[(size_t) c]);

                        // Micro time scaling: faster under higher macro load and higher bias (more responsive)
                        const double microSec = kMicroSecBase / (1.0 + kCouple * macro01 * (0.50 + 0.50 * bias01));

                        // Critically damped 2nd-order follower (stable discrete-time):
                        // Two cascaded one-pole followers with identical coefficient (no overshoot; no stiffness).
                        const double aU = std::exp (-(dtOS) / juce::jmax (1.0e-6, microSec));

                        microStage1DbState[(size_t) c] = aU * microStage1DbState[(size_t) c] + (1.0 - aU) * attnTargetDb;
                        microStage2DbState[(size_t) c] = aU * microStage2DbState[(size_t) c] + (1.0 - aU) * microStage1DbState[(size_t) c];

                        double y1 = microStage2DbState[(size_t) c];

                        // Containment (no negative attenuation; bounded max)
                        y1 = juce::jlimit (0.0, kMaxAttnDb, y1);
                        microStage2DbState[(size_t) c] = y1;

                        attnDbCh[(size_t) c] = y1;
                    }

                    // If more than 2 channels, treat channels >1 as linked to channel 1 (safe fallback; no reallocs).
                    if (numCh > 2)
                    {
                        for (int c = 2; c < numCh; ++c)
                            attnDbCh[1] = juce::jmax (attnDbCh[1], attnDbCh[0]);
                    }

                    // Stereo linking after envelope generation: max(GR_L, GR_R), linear blend.
                    const double linkedDb = juce::jmax (attnDbCh[0], attnDbCh[1]);
                    const double outDbL = (1.0 - link01) * attnDbCh[0] + link01 * linkedDb;
                    const double outDbR = (1.0 - link01) * attnDbCh[1] + link01 * linkedDb;

                    const double grDbNeg = -juce::jmax (outDbL, outDbR);
                    if (grDbNeg < grDbNegMin)
                        grDbNegMin = grDbNeg;

                    const double gL = std::pow (10.0, -outDbL / 20.0);
                    const double gR = std::pow (10.0, -outDbR / 20.0);

                    // Apply broadband gain (no frequency-selective attenuation).
                    if (numCh >= 1)
                    {
                        if (0 < osCached) osPtr[0][i] *= gL;
                        else osBlock.getChannelPointer (0)[i] *= gL;
                    }

                    if (numCh >= 2)
                    {
                        if (1 < osCached) osPtr[1][i] *= gR;
                        else osBlock.getChannelPointer (1)[i] *= gR;
                    }

                    for (int c = 2; c < numCh; ++c)
                    {
                        auto* p = (c < osCached ? osPtr[(size_t) c] : osBlock.getChannelPointer ((size_t) c));
                        p[i] *= gR;
                    }
                }
            }

            grDbForUI.store ((float) grDbNegMin, std::memory_order_relaxed);

            // Downsample back into blockN (workBufferDouble, native-rate length n)
            activeOversampler->processSamplesDown (blockN);

            // Copy double -> float output (native-rate)
            for (int c = 0; c < numCh; ++c)
            {
                const double* src = workBufferDouble.getReadPointer (c);
                float* dst = buffer.getWritePointer (c);
                for (int i = 0; i < n; ++i)
                    dst[i] = (float) src[i];
            }
            }
            else
            {
                // Deterministic advancement of smoothers (native-rate length n), with no audio-path work.
                driveDbSmoothed.skip (n);
                ceilingDbSmoothed.skip (n);
                adaptiveBias01Smoothed.skip (n);
                stereoLink01Smoothed.skip (n);

                grDbForUI.store (0.0f, std::memory_order_relaxed);
            }
        }
        else
        {
            // Native-rate fallback (prior behavior). No allocations. Deterministic.
            constexpr int kChCacheMax = 8;
            std::array<float*, (size_t) kChCacheMax> chPtr {};
            const int chCached = juce::jmin (numCh, kChCacheMax);
            for (int c = 0; c < chCached; ++c)
                chPtr[(size_t) c] = buffer.getWritePointer (c);

            double grDbNegMin = 0.0; // 0 dB (no reduction) down to -kMaxAttnDb

            for (int i = 0; i < n; ++i)
            {
                const double driveDb   = (double) driveDbSmoothed.getNextValue();
                const double ceilingDb = (double) ceilingDbSmoothed.getNextValue();
                const double bias01    = (double) adaptiveBias01Smoothed.getNextValue();
                const double link01    = (double) stereoLink01Smoothed.getNextValue();

                // Per-channel: compute attenuation target, then advance micro+macro.
                std::array<double, 2> attnDbCh { 0.0, 0.0 };

                const int chProc = juce::jmin (2, numCh);
                for (int c = 0; c < chProc; ++c)
                {
                    const float s = (c < chCached ? chPtr[(size_t) c][i] : buffer.getWritePointer (c)[i]);
                    const double tpDb = 20.0 * std::log10 ((double) std::abs (s) + kEpsLin);

                    // dB "over ceiling" after Drive (control-domain)
                    const double x = (tpDb + driveDb) - ceilingDb;

                    // Softplus(x) / kSoftK  (stable, smooth max(0,x))
                    const double z = kSoftK * x;
                    const double softplus = z + std::log1p (std::exp (-std::abs (z)));
                    double attnTargetDb = softplus / kSoftK;
                    attnTargetDb = juce::jlimit (0.0, kMaxAttnDb, attnTargetDb);

                    // Macro energy (bounded, monotonic): integrate required attenuation magnitude (linearized)
                    // energyInput = 0 when attnTargetDb == 0
                    const double energyInput = juce::jmax (0.0, std::pow (10.0, attnTargetDb / 20.0) - 1.0);

                    // Macro time scaling via Adaptive Bias (continuous scalar; no branching)
                    const double macroSec = kMacroSecBase * (1.20 - 0.40 * bias01); // [~0.8x .. ~1.2x] nominal
                    const double aM = std::exp (-(lastInvSampleRate) / juce::jmax (1.0e-6, macroSec));
                    macroEnergyState[(size_t) c] = aM * macroEnergyState[(size_t) c] + (1.0 - aM) * energyInput;

                    // Bound macro to avoid unbounded growth; mapping to [0,1) via energy/(1+energy)
                    const double macro01 = macroEnergyState[(size_t) c] / (1.0 + macroEnergyState[(size_t) c]);

                    // Micro time scaling: faster under higher macro load and higher bias (more responsive)
                    const double microSec = kMicroSecBase / (1.0 + kCouple * macro01 * (0.50 + 0.50 * bias01));

                    // Critically damped 2nd-order follower (stable discrete-time):
                    // Two cascaded one-pole followers with identical coefficient (no overshoot; no stiffness).
                    const double aU = std::exp (-(lastInvSampleRate) / juce::jmax (1.0e-6, microSec));

                    microStage1DbState[(size_t) c] = aU * microStage1DbState[(size_t) c] + (1.0 - aU) * attnTargetDb;
                    microStage2DbState[(size_t) c] = aU * microStage2DbState[(size_t) c] + (1.0 - aU) * microStage1DbState[(size_t) c];

                    double y1 = microStage2DbState[(size_t) c];

                    // Containment (no negative attenuation; bounded max)
                    y1 = juce::jlimit (0.0, kMaxAttnDb, y1);
                    microStage2DbState[(size_t) c] = y1;

                    attnDbCh[(size_t) c] = y1;
                }

                // If more than 2 channels, treat channels >1 as linked to channel 1 (safe fallback; no reallocs).
                if (numCh > 2)
                {
                    for (int c = 2; c < numCh; ++c)
                        attnDbCh[1] = juce::jmax (attnDbCh[1], attnDbCh[0]);
                }

                // Stereo linking after envelope generation: max(GR_L, GR_R), linear blend.
                const double linkedDb = juce::jmax (attnDbCh[0], attnDbCh[1]);
                const double outDbL = (1.0 - link01) * attnDbCh[0] + link01 * linkedDb;
                const double outDbR = (1.0 - link01) * attnDbCh[1] + link01 * linkedDb;

                const double grDbNeg = -juce::jmax (outDbL, outDbR);
                if (grDbNeg < grDbNegMin)
                    grDbNegMin = grDbNeg;

                const float gL = (float) std::pow (10.0, -outDbL / 20.0);
                const float gR = (float) std::pow (10.0, -outDbR / 20.0);

                // Apply broadband gain (no frequency-selective attenuation).
                if (numCh >= 1)
                {
                    if (0 < chCached) chPtr[0][i] *= gL;
                    else buffer.getWritePointer (0)[i] *= gL;
                }

                if (numCh >= 2)
                {
                    if (1 < chCached) chPtr[1][i] *= gR;
                    else buffer.getWritePointer (1)[i] *= gR;
                }

                for (int c = 2; c < numCh; ++c)
                    buffer.getWritePointer (c)[i] *= gR;
            }

            grDbForUI.store ((float) grDbNegMin, std::memory_order_relaxed);
        }
    }

    // Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::processBlockBypassed (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // True bypass: do not touch transport/smoothers/adaptive state.
    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // Session reload must restore identical internal state.
    auto root = apvts->copyState().createXml();
    if (root == nullptr)
        root = std::make_unique<juce::XmlElement> ("PARAMS");

    auto* internal = root->createNewChildElement ("internal_state");
    internal->setAttribute ("transportKnown", (int) transportKnown);
    internal->setAttribute ("lastTransportPlaying", (int) lastTransportPlaying);

    copyXmlToBinary (*root, destData);
}

void CompassMasteringLimiterAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (xml == nullptr)
        return;

    if (xml->hasTagName (apvts->state.getType()))
        apvts->replaceState (juce::ValueTree::fromXml (*xml));
    else
        apvts->replaceState (juce::ValueTree::fromXml (*xml));

    if (auto* internal = xml->getChildByName ("internal_state"))
    {
        transportKnown = (internal->getIntAttribute ("transportKnown", 0) != 0);
        lastTransportPlaying = (internal->getIntAttribute ("lastTransportPlaying", 0) != 0);
    }
    else
    {
        transportKnown = false;
        lastTransportPlaying = false;
    }

    // Constitution: recall/reload must restore identical internal state.
    // Do not hard-reset adaptive/envelope/guard state here.
    // Sync smoothed parameters to loaded values (no ramp) to prevent discontinuities.
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}


void CompassMasteringLimiterAudioProcessor::prepareOversampling (int channels, int maxBlock)
{
    const int ch = juce::jmax (1, channels);
    const int mb = juce::jmax (1, maxBlock);

    // Prebuild 2x/4x/8x with FIR equiripple halfband filters (linear-phase).
    for (int i = 0; i < kOsCount; ++i)
    {
        const int stages = i + 1; // 1->2x, 2->4x, 3->8x
        oversamplers[(size_t) i] = std::make_unique<juce::dsp::Oversampling<double>>(
            ch,
            stages,
            juce::dsp::Oversampling<double>::filterHalfBandFIREquiripple,
            true
        );

        oversamplers[(size_t) i]->initProcessing ((size_t) mb);
        oversamplers[(size_t) i]->reset();

        oversamplerLatencySamples[(size_t) i] = oversamplers[(size_t) i]->getLatencyInSamples();
    }

    // Scratch buffer for input conversion (double precision).
    workBufferDouble.setSize (ch, mb, false, false, true);

    // Default active oversampler is 2x until boundary latch selects otherwise.
    activeOversampler = oversamplers[0].get();
    setLatencySamples (oversamplerLatencySamples[0]);
}

void CompassMasteringLimiterAudioProcessor::selectOversamplingAtBoundary (int osMinIndex) noexcept
{
    const int idx = juce::jlimit (0, kOsCount - 1, osMinIndex);
    latchedOsMinIndex = idx;

    auto* os = oversamplers[(size_t) idx].get();
    if (os != nullptr)
    {
        activeOversampler = os;
        setLatencySamples (oversamplerLatencySamples[(size_t) idx]);

        // Deterministic, transport-safe boundary behavior:
        // reset oversampler state only when latching selection (not per block).
        activeOversampler->reset();
    }
}

void CompassMasteringLimiterAudioProcessor::measureTruePeak (const juce::AudioBuffer<float>& buffer) noexcept
{
    truePeakLin = 0.0;

    if (activeOversampler == nullptr)
        return;

    const int ch = juce::jmin (workBufferDouble.getNumChannels(), buffer.getNumChannels());
    const int n  = juce::jmin (workBufferDouble.getNumSamples(),  buffer.getNumSamples());
    if (ch <= 0 || n <= 0)
        return;

    // If input is effectively silent, reset oversampler state to prevent denormal accumulation


    // in FIR filter history (common crackle source under heavy attenuation / silence).


    constexpr float kSilenceLin = 1.0e-8f;


    float inPeak = 0.0f;


    for (int c = 0; c < ch; ++c)


    {


        const float* src = buffer.getReadPointer (c);


        for (int i = 0; i < n; ++i)


        {


            const float a = std::abs (src[i]);


            if (a > inPeak) inPeak = a;


        }


    }


    if (inPeak < kSilenceLin)


    {


        truePeakLin = 0.0;


        activeOversampler->reset();


        return;


    }



    // Convert input to double for oversampled reconstruction.
    for (int c = 0; c < ch; ++c)
    {
        const float* src = buffer.getReadPointer (c);
        double* dst = workBufferDouble.getWritePointer (c);
        for (int i = 0; i < n; ++i)
            dst[i] = (double) src[i];
    }

    juce::dsp::AudioBlock<double> block (workBufferDouble);

    juce::ScopedNoDenormals innerNoDenormals; // extra guard for oversampler internals
    auto osBlock = activeOversampler->processSamplesUp (block);

    const int osCh = (int) osBlock.getNumChannels();
    const int osN  = (int) osBlock.getNumSamples();

    for (int c = 0; c < osCh; ++c)
    {
        auto* p = osBlock.getChannelPointer ((size_t) c);
        for (int i = 0; i < osN; ++i)
        {
            const double a = std::abs (p[i]);
            if (a > truePeakLin)
                truePeakLin = a;
        }
    }

    // No downsampling/audio-path processing yet (skeleton is pass-through).

    // Diagnostic only: if near-silence, reset oversampler state to rule out denormal accumulation.
    if (truePeakLin < 1.0e-5)
        activeOversampler->reset();

    // NOTE: Do not reset per block in normal operation; true-peak reconstruction must be continuous across blocks.
}

juce::AudioProcessorEditor* CompassMasteringLimiterAudioProcessor::createEditor()
{
    return new CompassMasteringLimiterAudioProcessorEditor (*this);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CompassMasteringLimiterAudioProcessor();
}
