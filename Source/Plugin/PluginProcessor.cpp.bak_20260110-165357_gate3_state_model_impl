#include "PluginProcessor.h"
#include "PluginEditor.h"

CompassMasteringLimiterAudioProcessor::CompassMasteringLimiterAudioProcessor()
: juce::AudioProcessor (BusesProperties()
#if ! JucePlugin_IsMidiEffect
 #if ! JucePlugin_IsSynth
    .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
 #endif
    .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
#endif
)
{
    apvts = std::make_unique<APVTS>(*this, nullptr, "PARAMS", createParameterLayout());
}

CompassMasteringLimiterAudioProcessor::APVTS::ParameterLayout
CompassMasteringLimiterAudioProcessor::createParameterLayout()
{
    APVTS::ParameterLayout layout;

    // IDs are constitution-locked (no aliases, no hidden controls)
    // Value ranges are defined exactly per Gate-2 spec.
    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "drive", 1 },
        "Drive",
        juce::NormalisableRange<float> { 0.0f, 20.0f, 0.01f },
        0.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 2) + " dB"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "ceiling", 1 },
        "Ceiling",
        juce::NormalisableRange<float> { -6.0f, 0.0f, 0.01f },
        -1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 2) + " dBTP"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "adaptive_bias", 1 },
        "Adaptive Bias",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        0.5f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int)
        {
            // Label mapping (UI/host display) while remaining continuous scalar:
            // 0.0 -> Transparent, 0.5 -> Balanced, 1.0 -> Aggressive
            if (v <= 0.001f) return juce::String ("Transparent");
            if (v >= 0.999f) return juce::String ("Aggressive");
            if (std::abs (v - 0.5f) <= 0.001f) return juce::String ("Balanced");
            return juce::String (v, 3);
        },
        [] (const juce::String& s)
        {
            if (s.equalsIgnoreCase ("Transparent")) return 0.0f;
            if (s.equalsIgnoreCase ("Balanced"))    return 0.5f;
            if (s.equalsIgnoreCase ("Aggressive"))  return 1.0f;
            return s.getFloatValue();
        }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "stereo_link", 1 },
        "Stereo Link",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v * 100.0f, 1) + " %"; },
        [] (const juce::String& s) { return s.getFloatValue() / 100.0f; }
    ));

    layout.add (std::make_unique<juce::AudioParameterChoice>(
        juce::ParameterID { "oversampling_min", 1 },
        "Oversampling Min",
        juce::StringArray { "2×", "4×", "8×" },
        0
    ));

    return layout;
}

void CompassMasteringLimiterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);

    // Gate-2 smoothing policy (sample-accurate where needed once DSP is introduced).
    // For now we configure ramp times and keep the processing allocation-free.
    const double sr = (sampleRate > 0.0 ? sampleRate : 44100.0);

    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.reset (sr, 0.020);     // 20 ms
    ceilingDbSmoothed.reset (sr, 0.020);   // 20 ms
    adaptiveBias01Smoothed.reset (sr, 0.050); // 50 ms
    stereoLink01Smoothed.reset (sr, 0.050);   // 50 ms

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}

void CompassMasteringLimiterAudioProcessor::releaseResources()
{
}

bool CompassMasteringLimiterAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (! out.isDisabled());
}

void CompassMasteringLimiterAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // Gate-2 rule: read params once per block into locals (atomics -> locals).
    const float driveDbTarget   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDbTarget = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01Target    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01Target    = apvts->getRawParameterValue ("stereo_link")->load();
    const int   osMinIndex      = (int) apvts->getRawParameterValue ("oversampling_min")->load();

    juce::ignoreUnused (osMinIndex);

    driveDbSmoothed.setTargetValue (driveDbTarget);
    ceilingDbSmoothed.setTargetValue (ceilingDbTarget);
    adaptiveBias01Smoothed.setTargetValue (bias01Target);
    stereoLink01Smoothed.setTargetValue (link01Target);

    // Advance smoothing once per block (DSP integration will use per-sample where required).
    juce::ignoreUnused (driveDbSmoothed.getNextValue(),
                        ceilingDbSmoothed.getNextValue(),
                        adaptiveBias01Smoothed.getNextValue(),
                        stereoLink01Smoothed.getNextValue());

    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

juce::AudioProcessorEditor* CompassMasteringLimiterAudioProcessor::createEditor()
{
    return new CompassMasteringLimiterAudioProcessorEditor (*this);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CompassMasteringLimiterAudioProcessor();
}
