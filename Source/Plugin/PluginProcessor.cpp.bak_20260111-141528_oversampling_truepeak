#include "PluginProcessor.h"
#include "PluginEditor.h"

CompassMasteringLimiterAudioProcessor::CompassMasteringLimiterAudioProcessor()
: juce::AudioProcessor (BusesProperties()
#if ! JucePlugin_IsMidiEffect
 #if ! JucePlugin_IsSynth
    .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
 #endif
    .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
#endif
)
{
    apvts = std::make_unique<APVTS>(*this, nullptr, "PARAMS", createParameterLayout());
}

CompassMasteringLimiterAudioProcessor::APVTS::ParameterLayout
CompassMasteringLimiterAudioProcessor::createParameterLayout()
{
    APVTS::ParameterLayout layout;

    // IDs are constitution-locked (no aliases, no hidden controls)
    // Value ranges are defined exactly per Gate-2 spec.
    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "drive", 1 },
        "Drive",
        juce::NormalisableRange<float> { 0.0f, 20.0f, 0.01f },
        0.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dB"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "ceiling", 1 },
        "Ceiling",
        juce::NormalisableRange<float> { -6.0f, 0.0f, 0.01f },
        -0.3f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v, 1) + " dBTP"; },
        [] (const juce::String& s) { return s.getFloatValue(); }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "adaptive_bias", 1 },
        "Adaptive Bias",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        0.5f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int)
        {
            // Label-only display (constitution): continuous scalar, descriptive labels only.
            // Mapping for display text only:
            // <= 1/3 -> Transparent, >= 2/3 -> Aggressive, else -> Balanced
            if (v <= (1.0f / 3.0f)) return juce::String ("Transparent");
            if (v >= (2.0f / 3.0f)) return juce::String ("Aggressive");
            return juce::String ("Balanced");
        },
        [] (const juce::String& s)
        {
            if (s.equalsIgnoreCase ("Transparent")) return 0.0f;
            if (s.equalsIgnoreCase ("Balanced"))    return 0.5f;
            if (s.equalsIgnoreCase ("Aggressive"))  return 1.0f;
            return s.getFloatValue();
        }
    ));

    layout.add (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { "stereo_link", 1 },
        "Stereo Link",
        juce::NormalisableRange<float> { 0.0f, 1.0f, 0.0001f },
        1.0f,
        juce::String(),
        juce::AudioProcessorParameter::genericParameter,
        [] (float v, int) { return juce::String (v * 100.0f, 1) + " %"; },
        [] (const juce::String& s) { return s.getFloatValue() / 100.0f; }
    ));

    layout.add (std::make_unique<juce::AudioParameterChoice>(
        juce::ParameterID { "oversampling_min", 1 },
        "Oversampling Min",
        juce::StringArray { "2x", "4x", "8x" },
        0
    ));

    return layout;
}

void CompassMasteringLimiterAudioProcessor::reset (double sampleRate, int maxBlock, int channels) noexcept
{
    lastSampleRate = (sampleRate > 0.0 ? sampleRate : 44100.0);
    lastMaxBlock   = (maxBlock > 0 ? maxBlock : 0);
    lastChannels   = (channels > 0 ? channels : 0);

    // Deterministic reset of adaptive/envelope/guard state:
    // (DSP cores will be reset here once introduced.)
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.reset (lastSampleRate, 0.020);        // 20 ms
    ceilingDbSmoothed.reset (lastSampleRate, 0.020);      // 20 ms
    adaptiveBias01Smoothed.reset (lastSampleRate, 0.050); // 50 ms
    stereoLink01Smoothed.reset (lastSampleRate, 0.050);   // 50 ms

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}

void CompassMasteringLimiterAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
    reset (sampleRate, samplesPerBlock, ch);

    // Transport becomes unknown on prepare (hosts differ); edge detection begins on first block.
    transportKnown = false;
    lastTransportPlaying = false;
}

void CompassMasteringLimiterAudioProcessor::releaseResources()
{
}

bool CompassMasteringLimiterAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (! out.isDisabled());
}

void CompassMasteringLimiterAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // Gate-3 deterministic transport semantics:
    // transport stop/start resets adaptive/envelope/guard states.
    if (auto* ph = getPlayHead())
    {
        juce::AudioPlayHead::CurrentPositionInfo pos;
        if (ph->getCurrentPosition (pos))
        {
            const bool playingNow = pos.isPlaying;
            if (! transportKnown)
            {
                transportKnown = true;
                lastTransportPlaying = playingNow;
            }
            else if (playingNow != lastTransportPlaying)
            {
                lastTransportPlaying = playingNow;

                const int ch = juce::jmax (getTotalNumInputChannels(), getTotalNumOutputChannels());
                reset (lastSampleRate, lastMaxBlock, ch);
            }
        }
    }

    // Gate-2 rule: read params once per block into locals (atomics -> locals).
    const float driveDbTarget   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDbTarget = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01Target    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01Target    = apvts->getRawParameterValue ("stereo_link")->load();
    const int   osMinIndex      = (int) apvts->getRawParameterValue ("oversampling_min")->load();

    juce::ignoreUnused (osMinIndex);

    driveDbSmoothed.setTargetValue (driveDbTarget);
    ceilingDbSmoothed.setTargetValue (ceilingDbTarget);
    adaptiveBias01Smoothed.setTargetValue (bias01Target);
    stereoLink01Smoothed.setTargetValue (link01Target);

    // Advance smoothing once per block (DSP integration will use per-sample where required).
    juce::ignoreUnused (driveDbSmoothed.getNextValue(),
                        ceilingDbSmoothed.getNextValue(),
                        adaptiveBias01Smoothed.getNextValue(),
                        stereoLink01Smoothed.getNextValue());

    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::processBlockBypassed (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::ScopedNoDenormals noDenormals;

    // True bypass: do not touch transport/smoothers/adaptive state.
    // Skeleton behavior: pass-through. Clear any output channels with no input.
    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());
}

void CompassMasteringLimiterAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // Session reload must restore identical internal state.
    auto root = apvts->copyState().createXml();
    if (root == nullptr)
        root = std::make_unique<juce::XmlElement> ("PARAMS");

    auto* internal = root->createNewChildElement ("internal_state");
    internal->setAttribute ("transportKnown", (int) transportKnown);
    internal->setAttribute ("lastTransportPlaying", (int) lastTransportPlaying);

    copyXmlToBinary (*root, destData);
}

void CompassMasteringLimiterAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (xml == nullptr)
        return;

    if (xml->hasTagName (apvts->state.getType()))
        apvts->replaceState (juce::ValueTree::fromXml (*xml));
    else
        apvts->replaceState (juce::ValueTree::fromXml (*xml));

    if (auto* internal = xml->getChildByName ("internal_state"))
    {
        transportKnown = (internal->getIntAttribute ("transportKnown", 0) != 0);
        lastTransportPlaying = (internal->getIntAttribute ("lastTransportPlaying", 0) != 0);
    }
    else
    {
        transportKnown = false;
        lastTransportPlaying = false;
    }

    // Constitution: recall/reload must restore identical internal state.
    // Do not hard-reset adaptive/envelope/guard state here.
    // Sync smoothed parameters to loaded values (no ramp) to prevent discontinuities.
    const float driveDb   = apvts->getRawParameterValue ("drive")->load();
    const float ceilingDb = apvts->getRawParameterValue ("ceiling")->load();
    const float bias01    = apvts->getRawParameterValue ("adaptive_bias")->load();
    const float link01    = apvts->getRawParameterValue ("stereo_link")->load();

    driveDbSmoothed.setCurrentAndTargetValue (driveDb);
    ceilingDbSmoothed.setCurrentAndTargetValue (ceilingDb);
    adaptiveBias01Smoothed.setCurrentAndTargetValue (bias01);
    stereoLink01Smoothed.setCurrentAndTargetValue (link01);
}

juce::AudioProcessorEditor* CompassMasteringLimiterAudioProcessor::createEditor()
{
    return new CompassMasteringLimiterAudioProcessorEditor (*this);
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CompassMasteringLimiterAudioProcessor();
}
