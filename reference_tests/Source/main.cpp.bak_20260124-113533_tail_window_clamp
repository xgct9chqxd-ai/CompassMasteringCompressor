#include <iostream>
#include <cmath>
#include <limits>
#include <cstdlib>
#include <cstdint>

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_basics/juce_audio_basics.h>

#include "reference_core/reference_core.h"
#include "PluginProcessor.h"

static bool bufferAllFinite (const juce::AudioBuffer<float>& b) noexcept
{
    for (int ch = 0; ch < b.getNumChannels(); ++ch)
    {
        const float* p = b.getReadPointer (ch);
        for (int i = 0; i < b.getNumSamples(); ++i)
        {
            const float v = p[i];
            if (! std::isfinite ((double) v))
                return false;
        }
    }
    return true;
}

static float bufferPeakAbs (const juce::AudioBuffer<float>& b) noexcept
{
    float pk = 0.0f;
    for (int ch = 0; ch < b.getNumChannels(); ++ch)
    {
        const float* p = b.getReadPointer (ch);
        for (int i = 0; i < b.getNumSamples(); ++i)
            pk = std::max (pk, std::abs (p[i]));
    }
    return pk;
}

static double bufferMean (const juce::AudioBuffer<float>& b) noexcept
{
    double sum = 0.0;
    int64_t n = 0;
    for (int ch = 0; ch < b.getNumChannels(); ++ch)
    {
        const float* p = b.getReadPointer (ch);
        for (int i = 0; i < b.getNumSamples(); ++i)
        {
            sum += (double) p[i];
            ++n;
        }
    }
    return (n > 0 ? (sum / (double) n) : 0.0);
}

static double bufferRms (const juce::AudioBuffer<float>& b) noexcept
{
    double sum2 = 0.0;
    int64_t n = 0;
    for (int ch = 0; ch < b.getNumChannels(); ++ch)
    {
        const float* p = b.getReadPointer (ch);
        for (int i = 0; i < b.getNumSamples(); ++i)
        {
            const double v = (double) p[i];
            sum2 += v * v;
            ++n;
        }
    }
    return (n > 0 ? std::sqrt (sum2 / (double) n) : 0.0);
}

static int envInt (const char* k, int defv) noexcept
{
    if (const char* v = std::getenv (k))
    {
        try { return std::max (0, std::stoi (v)); }
        catch (...) { return defv; }
    }
    return defv;
}

static double envDouble (const char* k, double defv) noexcept
{
    if (const char* v = std::getenv (k))
    {
        try { return std::max (0.0, std::stod (v)); }
        catch (...) { return defv; }
    }
    return defv;
}

static uint32_t envU32 (const char* k, uint32_t defv) noexcept
{
    if (const char* v = std::getenv (k))
    {
        try
        {
            const unsigned long long x = std::stoull (v);
            return (uint32_t) (x & 0xFFFFFFFFu);
        }
        catch (...) { return defv; }
    }
    return defv;
}

static void setParamRaw (CompassMasteringLimiterAudioProcessor& proc, const char* id, float v) noexcept
{
    auto* p = proc.getAPVTS().getRawParameterValue (id);
    if (p != nullptr) p->store (v, std::memory_order_relaxed);
}

int main()
{
    juce::ScopedJuceInitialiser_GUI juceInit;

    const bool okCore = (reference_core::kReferenceCoreId != nullptr);
    if (! okCore)
    {
        std::cout << "reference_tests FAIL (reference_core)\n";
        return 1;
    }

    constexpr double kProbeToneHz = 1000.0;
    constexpr float  kToneAmpLin = 0.999f;

    constexpr float  kDriveMaxDb = 20.0f;
    constexpr float  kCeilingHardDbTP = -0.3f;
    constexpr float  kAdaptiveBiasAgg01 = 1.0f;
    constexpr int    kOversamplingMaxIndex = 2;

    constexpr double kSilenceTailSecDefault = 2.0;
    constexpr double kSilenceRmsMaxDb = -110.0;
    constexpr double kDcMaxDb = -120.0;

    constexpr double kLn10 = 2.30258509299404568402;
    const auto dbToLin = [](double db) -> double { return std::exp ((db * kLn10) / 20.0); };
    const auto linToDb = [](double lin) -> double
    {
        const double x = std::max (lin, 1.0e-20);
        return 20.0 * std::log10 (x);
    };

    const double silenceRmsMaxLin = dbToLin (kSilenceRmsMaxDb);
    const double dcMaxLin = dbToLin (kDcMaxDb);

    const int itersPerCase = std::max (1, envInt ("CML_TEST_ITERS", 400));
    const double silenceTailSec = envDouble ("CML_TEST_SILENCE_TAIL_SEC", kSilenceTailSecDefault);
    const uint32_t seed = envU32 ("CML_TEST_SEED", 0xC0FFEEu);

    //// [CML:TEST] Processor Lifecycle Smoke
    CompassMasteringLimiterAudioProcessor proc;
    proc.setPlayConfigDetails (2, 2, 44100.0, 512);

    auto runOne = [&proc, &dbToLin, &linToDb, silenceRmsMaxLin, dcMaxLin, itersPerCase, silenceTailSec, seed](double sr, int bs, bool stress) -> bool
    {
        proc.prepareToPlay (sr, bs);

        const int latencySamples = proc.getLatencySamples();
        const int graceBlocksFromLatency = (latencySamples > 0 ? (int) std::ceil ((double) latencySamples / (double) bs) : 0);

        // Always allow a minimum grace time to flush any internal pipelines (even if host latency is 0).
        constexpr double kTailGraceMinSec = 0.25;
        const int graceBlocksMinTime = (int) std::ceil ((kTailGraceMinSec * sr) / (double) bs);

        const int graceBlocks = std::max (graceBlocksFromLatency + 2, graceBlocksMinTime);

        setParamRaw (proc, "trim", 0.0f);
        setParamRaw (proc, "stereo_link", 1.0f);

        if (stress)
        {
            setParamRaw (proc, "drive", kDriveMaxDb);
            setParamRaw (proc, "ceiling", kCeilingHardDbTP);
            setParamRaw (proc, "adaptive_bias", kAdaptiveBiasAgg01);
            auto* os = proc.getAPVTS().getRawParameterValue ("oversampling_min");
            if (os != nullptr) os->store ((float) kOversamplingMaxIndex, std::memory_order_relaxed);
        }
        else
        {
            setParamRaw (proc, "drive", 0.0f);
            setParamRaw (proc, "ceiling", kCeilingHardDbTP);
            setParamRaw (proc, "adaptive_bias", 0.5f);
            auto* os = proc.getAPVTS().getRawParameterValue ("oversampling_min");
            if (os != nullptr) os->store (0.0f, std::memory_order_relaxed);
        }

        juce::AudioBuffer<float> buf (2, bs);
        juce::MidiBuffer midi;

        uint32_t prng = (seed ^ (uint32_t) (sr * 0.001) ^ (uint32_t) (bs * 131));
        auto rnd01 = [&prng]() -> float
        {
            prng = prng * 1664525u + 1013904223u;
            const uint32_t x = (prng >> 8) & 0x00FFFFFFu;
            return (float) x / (float) 0x01000000u;
        };

        double phase = 0.0;
        const double w = 2.0 * 3.14159265358979323846 * kProbeToneHz / sr;

        for (int i = 0; i < bs; ++i)
        {
            const float d = stress ? (0.02f * (rnd01() - 0.5f)) : 0.0f;
            const float s = (float) std::sin (phase) * kToneAmpLin + d;
            phase += w;
            buf.setSample (0, i, s);
            buf.setSample (1, i, s);
        }

        for (int k = 0; k < itersPerCase; ++k)
        {
            proc.processBlock (buf, midi);
            if (! bufferAllFinite (buf))
                return false;
        }

        const float pk = bufferPeakAbs (buf);
        if (! std::isfinite ((double) pk))
            return false;

        const int tailBlocks = (int) std::ceil ((silenceTailSec * sr) / (double) bs);

        constexpr double kTailLateWindowSec = 0.5; // enforce silence only at end of tail window
        const int lateWindowBlocks = (int) std::max (1.0, std::ceil ((kTailLateWindowSec * sr) / (double) bs));
        const int startMeasureK = std::max (0, tailBlocks - lateWindowBlocks);
        for (int i = 0; i < bs; ++i)
        {
            buf.setSample (0, i, 0.0f);
            buf.setSample (1, i, 0.0f);
        }

        double tailRmsMax = 0.0;
        double tailDcMax = 0.0;
        double tailRmsMaxAfterGrace = 0.0;
        double tailDcMaxAfterGrace  = 0.0;

        for (int k = 0; k < std::max (1, tailBlocks); ++k)
        {
            buf.clear();
            proc.processBlock (buf, midi);
            if (! bufferAllFinite (buf))
                return false;
if (! bufferAllFinite (buf))
                return false;
            const double blockRms = bufferRms (buf);
            const double blockMeanAbs = std::abs (bufferMean (buf));
            const double blockPeakLin = (double) bufferPeakAbs (buf);

            if (! std::isfinite (blockRms) || ! std::isfinite (blockMeanAbs) || ! std::isfinite (blockPeakLin))
            {
                std::cout << "reference_tests DETAIL: non-finite tail stats"
                          << " sr=" << (int) sr << " bs=" << bs
                          << " stress=" << (stress ? 1 : 0)
                          << " k=" << k << "/" << tailBlocks
                          << " rmsLin=" << blockRms
                          << " meanAbsLin=" << blockMeanAbs
                          << " peakLin=" << blockPeakLin
                          << "\n";
                return false;
            }

            if (k >= graceBlocks && blockRms > silenceRmsMaxLin)

            {

                std::cout << "reference_tests DETAIL: tail RMS exceeds limit (early)"
                          << " sr=" << (int) sr << " bs=" << bs
                          << " stress=" << (stress ? 1 : 0)
                          << " iters=" << itersPerCase
                          << " k=" << k << "/" << tailBlocks
                          << " rmsDb=" << linToDb (blockRms)
                          << " limitDb=" << linToDb (silenceRmsMaxLin)
                          << " rmsLin=" << blockRms
                          << " limitLin=" << silenceRmsMaxLin
                          << " peakDb=" << linToDb (blockPeakLin)
                          << " peakLin=" << blockPeakLin
                          << " meanAbsDb=" << linToDb (blockMeanAbs)
                          << " meanAbsLin=" << blockMeanAbs
                          << " s0[0..7]=";

                const float* p0 = buf.getReadPointer (0);
                const int nDump = std::min (8, buf.getNumSamples());
                for (int i = 0; i < nDump; ++i)
                    std::cout << (i ? "," : "") << p0[i];

                std::cout << "\n";
                return false;
            }







            const double blockMean = bufferMean (buf);




            if (k >= startMeasureK)




                tailRmsMax = std::max (tailRmsMax, blockRms);




            if (k >= startMeasureK)




                tailDcMax  = std::max (tailDcMax,  blockMeanAbs);




            if (k >= graceBlocks)




            {




                tailRmsMaxAfterGrace = std::max (tailRmsMaxAfterGrace, blockRms);




                tailDcMaxAfterGrace  = std::max (tailDcMaxAfterGrace,  blockMeanAbs);




            }
        }

        if (! std::isfinite (tailRmsMax) || ! std::isfinite (tailDcMax))
        {
            std::cout << "reference_tests DETAIL: non-finite tail" << " sr=" << (int) sr << " bs=" << bs << " stress=" << (stress ? 1 : 0) << " iters=" << itersPerCase << " tailBlocks=" << tailBlocks << " tailRmsLin=" << tailRmsMax << " tailDcLin=" << tailDcMax << "\n";
            return false;
        }

        if (tailRmsMax > silenceRmsMaxLin)
        {
            std::cout << "reference_tests DETAIL: silence RMS too high" << " sr=" << (int) sr << " bs=" << bs << " stress=" << (stress ? 1 : 0) << " iters=" << itersPerCase << " tailBlocks=" << tailBlocks << " tailRmsDb=" << linToDb (tailRmsMax) << " limitDb=" << linToDb (silenceRmsMaxLin) << " tailRmsLin=" << tailRmsMax << " limitLin=" << silenceRmsMaxLin << " lateWindowBlocks=" << lateWindowBlocks << " startMeasureK=" << startMeasureK << "\n";
            return false;
        }

        if (tailDcMax > dcMaxLin)
        {
            std::cout << "reference_tests DETAIL: DC too high" << " sr=" << (int) sr << " bs=" << bs << " stress=" << (stress ? 1 : 0) << " iters=" << itersPerCase << " tailBlocks=" << tailBlocks << " tailDcDb=" << linToDb (tailDcMax) << " limitDb=" << linToDb (dcMaxLin) << " tailDcLin=" << tailDcMax << " limitLin=" << dcMaxLin << "\n";
            return false;
        }

        proc.releaseResources();
        return true;
    };

    //// [CML:TEST] Block Size Sweep Stability
    const int blockSizes[] = { 16, 32, 64, 128, 256, 512, 1024 };
    for (int bs : blockSizes)
    {
        if (! runOne (44100.0, bs, false))
        {
            std::cout << "reference_tests FAIL (block " << bs << " neutral)\n";
            return 1;
        }
        if (! runOne (44100.0, bs, true))
        {
            std::cout << "reference_tests FAIL (block " << bs << " stress)\n";
            return 1;
        }
    }

    //// [CML:TEST] Sample Rate Sweep Stability
    const double sampleRates[] = { 44100.0, 48000.0, 96000.0, 192000.0 };
    for (double sr : sampleRates)
    {
        if (! runOne (sr, 256, false))
        {
            std::cout << "reference_tests FAIL (sr " << (int) sr << " neutral)\n";
            return 1;
        }
        if (! runOne (sr, 256, true))
        {
            std::cout << "reference_tests FAIL (sr " << (int) sr << " stress)\n";
            return 1;
        }
    }

    //// [CML:TEST] Offline Huge Block Stability
    if (! runOne (48000.0, 8192, true))
    {
        std::cout << "reference_tests FAIL (huge block 8192 stress)\n";
        return 1;
    }

    std::cout << "reference_tests PASS\n";
    return 0;
}
